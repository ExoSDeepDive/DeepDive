# 배퀴즈온더블럭
1. 출력될 값들을 순서대로 적고 그 이유를 설명하세요. (ref p.411)
```jsx
  const Person = (function () {
    let _age = 0
    
    function Person(name, age) {
      this.name = name;
      _age = age;
    }
    
    Person.prototype.sayAge = function () {
      console.log(_age);
    }
    
    return Person;
  }());
  
  const me = new Person('Bae', 7);
  me.sayAge();
  console.log(me._age);
```

2. 아래 코드에서의 메서드 체이닝이 가능한 이유를 인스턴스의 측면에서 설명하세요. (ref p.467)
```jsx
  class MyArray extends Array {
    average() {
      return this.reduce((a, b) -> a + b, 0) / this.length;
    }
  }
  
  const myArray = new MyArray(1, 2, 3, 4)
  myArray.filter(x => x > 1).average();
``` 

# 24장 - 클로저

### 용어 정리

- 스코프: 코드가 식별자를 참조할 수 있는, 즉 식별자가 유효한 범위
- 실행 컨텍스트
    - 정의: 코드를 실행하는데 필요한 환경(스코프)을 제공하고 코드의 실행을 직접적으로 관리하는 영역
    - 구성
        - 렉시컬 환경
            - 스코프의 실체로, 식별자와 그 값, 상위 스코프에 대한 참조를 기록하는 자료구조
        - 실행 컨텍스트 스택
            - 코드 블럭에 따라 실행 순서를 관리하는 메커니즘으로서 자료구조
            

### 렉시컬 스코프

- 렉시컬 스코프
    - 상위 스코프를 참조하는 방식에 대한 개념
    
- 함수의 렉시컬 스코프
    - 렉시컬 환경의 상위 스코프는 함수가 실행되는 환경이 아닌 함수가 정의된 환경에 의해 결정된다
    
    ```jsx
    const x = 1;
    
    function foo() {
    	const x = 10;
    
    	bar();
    }
    
    function bar() {
    	console.log(x)
    }
    
    foo() // ?
    bar() // ?
    ```
    
    - 렉시컬 스코프가 가능하기 위해 상위 스코프의 참조를 함수의 내부 슬롯 [[Environment]]에 저장한다.

### 클로저와 렉시컬 환경

- 정의
    - 이미 생명주기가 종료된 외부 함수(상위 스코프)의 변수를 참조하는 중첩 함수
        - 외부함수의 렉시컬 환경이 소멸하지 않는 이유
            - **중첩함수가 외부로 리턴되어** 상위 스코프에서 참조되고 있고
            - 렉시컬 스코프 방식으로 인해 중첩함수의 [[Environment]] 슬롯에 저장되어있기 때문이다.
- 자유 변수
    - 정의: 클로저에 의해 참조되는 상위 스코프의 변수
    - 클로저라는 이름은 함수가 자유함수에 묶여있다(closed)는 개념에 기반한 용어

### 클로저 활용

- 이유
    - 상태를 은닉하고 특정 함수에게만 상태 변경을 허용하기 위함.
    
- 방식
    - 즉시 실행 함수가 생성한 렉시컬 환경에 자유 변수를 등록하고, 클로저를 리턴한다.
    - 즉시 실행 함수가 소멸하였지만 클로저는 즉시 실행 함수가 생성한 렉시컬 환경에 접근할 수 있다.
    - 해당 자유 변수는 클로저만 접근할 수 있다. ⇒ 은닉

### 캡슐화와 정보 은닉

- 캡슐화란
    - 객체의 상태와 동작을 하나로 묶는 것
    
- 접근 제한자
    - 자바스크립트는 public, private, protected를 제공하지 않음. 기본적으로 모든 프로퍼티와 메서드는 public임.
    - private하게 관리하기 위해서는 지역 스코프 내에서 선언하고, 해당 변수에 인스턴스가 접근할 수 있도록 생성자 함수를 클로저로 리턴하면 된다.
    - 하지만 위의 방식은 여러 인스턴스가 하나의 렉시컬 환경을 참조한다는 점에서 변수의 상태가 유지되지 않는다.
    - typescript를 쓰거나, 새로운 표준 사양(TC39)을 확인해보자

# 25장 - 클래스

### 새로운 객체 생성 메커니즘으로서 클래스

- 클래스 또한 프로토타입 기반을 활용하고 있다.
- 차이점
    - new 키워드를 반드시 써야 한다.
    - `extends`, `super`
    - strict mode
    - [[Enumerable]]: `false`

### 호이스팅

- 기본적으로 함수로 평가됨.
- const, let과 같은 일시적 사각지대에 빠진다.
    - 식별자 선언은 런타임 이전에 되어 식별자 자체는 호이스팅되나, 식별자 평가(할당)는 런타임 중에 실행된다.
    

### 메서드

- constructor
    - 생성자 함수와 동일한 기능이나 같지 않음.
        
        prototype이 가진 constructor는 말 그대로 인스턴스를 생성하고 프로토타입을 내려주는 역할
        
        한편 class의 constructor는 위의 prototype.constructor와 동일한 기능을 수행하는 함수 객체. 그래서 메서드로 분류됨
        
    - constructor 내부에서 this는 인스턴스를 가리킴
    - 생성자 함수와 마찬가지로 this를 return
    
- 프로토타입 메서드 vs 정적 메서드
    
    
    |  | 프로토타입 메서드 | 정적 메서드 |
    | --- | --- | --- |
    | 키워드 |  | static |
    | 프로토타입 체인 | Class.prototype → Object.prototype | Class → Function.prototype |
    | 호출 방식 | 인스턴스로 호출 | 클래스로 호출 |
    | 인스턴스 참조 여부 | 가능 | 불가능 |

### 프로퍼티

- 인스턴스 프로퍼티
    - constructor 내부에서 this와 함께 선언해야 함.
- 접근자 프로퍼티(getter, setter)
- private 필드 제안 (TC39)
    - #을 붙이는 방식
    - 인스턴스 프로퍼티로 접근할 수 없지만 접근자 프로퍼티로 접근할 수 있음.
- static 필드 제안 (TC39)

### 상속

- 프로토타입 기반 vs 클래스 기반
    
    
    | 프로토타입 기반 | 클래스 기반 |
    | --- | --- |
    | 프로토타입 체인을 통해 상속 | 기존 클래스를 확장하여 새로운 클래스를 정의 |
    |  | 코드 재사용 관점에서 유리 |
- super
    - super() ⇒ 수퍼클래스의 constructor()
        - 서브클래스는 인스턴스 생성을 수퍼클래스에게 위임한다. 따라서 서브클래스에서 constructor를 사용하는 경우 반드시 super()를 호출해야 함
        
        - 하지만 new.target은 서브클래스를 가리킴. 아무래도 new로 호출한 것은 서브클래스라서?
        
        - this를 활용한 인스턴스 초기화 과정
            - super()
                - 수퍼클래스의 인스턴스 초기화
                - this(인스턴스 객체)를 서브클래스 constructor 내부로 리턴
            - super()가 리턴한 인스턴스를 this에 바인딩하여 재사용
            
    - super.method()를 통해 수퍼클래스의 메서드를 참조할 수 있다.
    
    - super의 작동 원리
        - super는 수퍼클래스의 prototype에 바인딩되어야한다.
        - 이를 위해서는 super를 참조하는 서브클래스의 메서드가 서브클래스의 프로토타입을 찾을 수 있어야 한다.
        - 메서드는 [[HomeObject]]라는 슬롯에 자신을 바인딩하고 있는 객체를 담고 있다.
        - 메서드가 축약표현로 선언된 경우에만 해당 슬롯을 가지며, 프로퍼티에 함수를 할당하는 경우에는 해당 슬롯이 없어 super를 참조할 수 없다.
