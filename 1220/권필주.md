
🔐 개념 숙지

> - 렉시컬 스코프
> - 함수 호출 방식별 this 바인딩
> - 실행컨텍스트 cf. 렉시컬 환경


💡생각해보기

> ## Quiz 1.
> JS의 모든 함수가 자신의 상위 스코프에 대한 참조를 저장하는 곳은? 

> ## Quiz 2.
> 중첩함수가 모두 클로저는 아니다. 상위 스코프의 식별자 참조, 생명주기를 중심으로 클로저의 정의를 다시 내려 보세요.



## 24장. 클로저

    “A closure is the combination of a function and the lexical environment within which that function was declared.” 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

### 렉시컬 스코프

JS엔진은 함수 호출이 아니라 함수 정의 위치에 따라 상위 스코프를 결정하는 것을 렉시컬스코프(정적스코프)라고 한다. 어디서 정의했느냐에 따라 상위 스코프는 정적으로 결정되고 변하지 않는다. 

왜 중요? 클로저의 핵심은 상위 스코프의 식별자 참조인데 이 상위 스코프가 정해지는 시점이 바로 함수 정의할때이기 때문. 

 **렉시컬 환경의 *외부 렉시컬 환경에 대한 참조*에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다**

### 함수 객체의 내부 슬롯 [[Environment]]

함수 정의가 위치하는 스코프가 함수의 상위 스코프가 되므로 이에 대한 참조를 저장해야한다→ 함수 객체의 내부 슬롯 [[Environment]]에 저장한다.

* 전역에서 정의된 함수 선언문 → 전역 코드 평가 시점에 실행중인 전역 렉시컬 환경의 참조 저장

* 함수 내부에 정의된 함수 표현식 → 외부 함수 코드 실행 시점에 실행 중인 외부함수 렉시컬 환경의 참조 저장

quiz

JS의 모든 함수가 자신의 상위 스코프에 대한 참조를 저장하는 곳은? 함수 객체의 내부 슬롯 [[Environment]]

### 클로저와 렉시컬 환경

외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수가 이미 생명 주기가 종료한 외부함수의 변수를 참조할 수 있다. 이러한 중첩함수를 클로저라고 부른다.

💡중첩함수면 클로저인가? 
상위 스코프의 어떤 식별자도 참조하지 않는 함수는 클로저가 아니다.

생명주기가 일찍 종료된 외부함수의 식별자를 참조할 수 있는, 즉 중첩함수 내부에 상위 스코프를 참조해 식별자를 참조하거나 값을 변경할 수도 있는 함수가 클로저다

💡그럼 외부 함수보다 일찍 소멸되는 클로저는 클로저인가? 상위 스코프의 식별자를 참조하더라도 생명주기가 종료된 외부함수의 식별자를 참조할 필요없이 외부함수보다 일직 소멸되어버린다면 이 역시 클로저가 아니다

클로저는 중첩함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수의 외부로 반환되어 외부함수보다 더 오래 유지되는 경우에 한정한다.(이게 일반적이다)

클로저 closure란 말의 뜻은 클로저에 의해 참조되는 상위 변수들을 자유 변수라고 부르는데 이 자유 변수에 대해 묶여있는, 즉 닫혀있다 closed란 의미이다. JS엔진은 최적화로 클로저가 참조하고 있지 않는 식별자는 기억하지 않는다.