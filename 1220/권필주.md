
🔐 개념 숙지

> - 클로저 개념 한 줄로
> - 프로토타입 매서드, 정적 매서드 구분
> - 클래스 필드


💡생각해보기

> ## Quiz 1.
> JS의 모든 함수가 자신의 상위 스코프에 대한 참조를 저장하는 곳(내부 슬롯)은? 

> ## Quiz 2.
> 중첩함수가 모두 클로저는 아니다. 상위 스코프의 식별자 참조, 생명주기를 중심으로 클로저의 정의를 다시 내려보세요.

> ## Quiz 3.
> 다음 코드에서 17~ 7출력 결과는?
```jsx
function makeCounter(aux){
	let counter = 0;
    this.check = counter;
	return function(){
		counter = aux(counter);
		return counter;
		};
}


function increase(n){
	return ++n
}

function decrease(n){
	return --n;
}

// 활용
const increaser = new makeCounter(increase);
console.log(increaser());  // 1.
console.log(increaser());  // 2.
console.log(decrease());  // 3.
console.log(decrease());  // 4.
console.log(check);  //5.
console.log(increaser.check);  //6.
console.log(increaser().check);  //7.
```

> ## Quiz 4.
> 위 코드에 이어 다음과 같이 decreaser를 만들때 출력되는 결과를 예상하고 위의 increaser함수와 카운터 상태가 연동되는지 그 이유는 무엇인지 적어보세요.
```jsx
const decreaser = makeCounter(decrease);
console.log(decreaser());  //1.
console.log(decreaser());  //2.
console.log(check);  //3.
```

> ## Quiz 5.
> 즉시실행함수와 클로저가 친한 이유?


## 24장. 클로저

    “A closure is the combination of a function and the lexical environment within which that function was declared.” 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

### 렉시컬 스코프

JS엔진은 함수 호출이 아니라 함수 정의 위치에 따라 상위 스코프를 결정하는 것을 렉시컬스코프(정적스코프)라고 한다. 어디서 정의했느냐에 따라 상위 스코프는 정적으로 결정되고 변하지 않는다. 

왜 중요? 클로저의 핵심은 상위 스코프의 식별자 참조인데 이 상위 스코프가 정해지는 시점이 바로 함수 정의할때이기 때문. 

 **렉시컬 환경의 *외부 렉시컬 환경에 대한 참조*에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다**

### 함수 객체의 내부 슬롯 [[Environment]]

함수 정의가 위치하는 스코프가 함수의 상위 스코프가 되므로 이에 대한 참조를 저장해야한다→ 함수 객체의 내부 슬롯 [[Environment]]에 저장한다.

* 전역에서 정의된 함수 선언문 → 전역 코드 평가 시점에 실행중인 전역 렉시컬 환경의 참조 저장

* 함수 내부에 정의된 함수 표현식 → 외부 함수 코드 실행 시점에 실행 중인 외부함수 렉시컬 환경의 참조 저장

quiz

JS의 모든 함수가 자신의 상위 스코프에 대한 참조를 저장하는 곳은? 함수 객체의 내부 슬롯 [[Environment]]

### 클로저와 렉시컬 환경

외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수가 이미 생명 주기가 종료한 외부함수의 변수를 참조할 수 있다. 이러한 중첩함수를 클로저라고 부른다.

💡중첩함수면 클로저인가? 
상위 스코프의 어떤 식별자도 참조하지 않는 함수는 클로저가 아니다.

생명주기가 일찍 종료된 외부함수의 식별자를 참조할 수 있는, 즉 중첩함수 내부에 상위 스코프를 참조해 식별자를 참조하거나 값을 변경할 수도 있는 함수가 클로저다

💡그럼 외부 함수보다 일찍 소멸되는 클로저는 클로저인가? 상위 스코프의 식별자를 참조하더라도 생명주기가 종료된 외부함수의 식별자를 참조할 필요없이 외부함수보다 일직 소멸되어버린다면 이 역시 클로저가 아니다

클로저는 중첩함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수의 외부로 반환되어 외부함수보다 더 오래 유지되는 경우에 한정한다.(이게 일반적이다)

클로저 closure란 말의 뜻은 클로저에 의해 참조되는 상위 변수들을 자유 변수라고 부르는데 이 자유 변수에 대해 묶여있는, 즉 닫혀있다 closed란 의미이다. JS엔진은 최적화로 클로저가 참조하고 있지 않는 식별자는 기억하지 않는다.

<br>

### 클로저의 활용

(이전)상태를 안전하게 변경하고 유지하기 위해 사용

***의도치 않은 상태 변경을 막고 상태를 안전하게 은닉하고 특정함수에게만 상태 변경을 허용하기 위해 사용한다.***

### 캡슐화와 정보 은닉

**캡슐화**

객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 매서드를 하나로 묶는 것.


## 25장. 클래스

클래스는 ES6에서 도입해 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있는 문법적 설탕 syntactic sugar으로 보기도 하지만 새로운 객체 생성 매커니즘으로 보는 것이 좀 더 합당하다.

클래스는 생성자함수와 매우 유사하지만 보다 엄격하고 명료, 견고하고 몇 가지 차이점이 있다.

- 클래스는new 연산자 없이 호출하면 에러 발생
    - 생성자 함수는 new 연산자 없이 호출하면 일반 함수로 호출됨
- 클래스 상속을 위해 extends, supere 키워드 제공
    - 생성자 함수는 두 키워드 지원 X
- 클래스는 호이스팅 발생하지 않는 것처럼 동작
    - 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅 발생
    - 함수 표현식으로 정의된 생성자 함수는 변수 호이스팅 발생
- 클래스는 암묵적으로 strict mode 지정되어 있어 해제할 수 없음
    - 생성자 함수는 암묵적 strict mode 지정 X
- 클래스의 constructor, 프로토타입 매세더, 정적 매서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이므로 열거되지 않는다

### 클래스 정의

class 키워드 사용

파스칼 케이스 ( 사용하지 않아도 에러 발생X)

클래스는 표현식으로 정의할 수 도 있다. 즉 클래스는 값으로 사용할 수 있는 일급 객체이다. 

클래스는 함수다. 

클래스 몸체에는 0개 이상의 매서드만 정의할 수 있다. 종류는 3가지

- constructor
- 프로토타입매서드
- 정적매서드

### 클래스 호이스팅

클래스 선언문으로 정의한 클래스는 함수 선언문 같이 소스코드 평가과정, 즉 런타임 이전에 먼져 평가되어 함수 객체를 생성한다.

let, const 로 선언한 변수처럼 호이스팅 된다. 즉 선언단계와 초기화 단계가 분리되어 선언문은 런타임 이전에 먼저 실행되어 참조하나 초기화는 런타임에 이뤄지는 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작 할 뿐이다.

### 인스턴스 생성

반드시 new 연산자와 함께 호출

### 매서드
**constructor**

- 클래스의 constructor 매서드는 클래스 내에 최대 한 개만 존재할 수 있다
- constructor는 생략 가능하다.
    - 생략하면 빈 constructor가 암묵적으로 정의되고 이는 빈 객체를 생성한다
- 프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 constructor 내부에서 this에 인스턴스 프로퍼티를 추가한다.
    - 따라서 인스턴스 생성과 동시에 초기화하려면 constructor를 생략하면 안된다.
- constructor는 별도의 반환문 return 을 갖지 않아야 한다. 반드시 return은 생략해야한다
    - new 연산자로 호출하면 생성자 함수와 동일하게 암묵적으로 this(인스턴스)가 반환된다.
    - 명시적으로 this가 아닌 다른 객체를 반환하면 인스턴스가 반환되지 못하고 return문에 명시된 객체가 반환된다.
    - 만약 원시값을 return 하면 원시값은 무시되고 암묵적으로 this가 반환된다. (그래도 클래스의 기본 동작을 훼손하므로 return문은 생략해야한다)

**프로토타입매서드**

생성자함수 이용해 인스턴스 생성하면서 프로토타입 매서드 생성하기 위해 `Person.prototype.sayHi =` 처럼 추가하지 않아도 클래스의 매서드는 기본적으로 프로토타입 매서드가 된다.

**정적매서드**

정적 매서드는 인스턴스를 생성하지 않아도 호출 할 수 있는 매서드다

클래스에는 static 키워드를 붙이면 정적 매서드(클래스 매서드)가 된다. 

정적 매서드는 인스턴스로 호출할 수 없다. 정적 매서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인상에 존재하지 않기 때문이다.

정적 매서드는 인스턴스 프로퍼티를 참조할 수 없다(인스턴스로 호출할 수 없으므로 당연한듯)

따라서 인스턴스 프로퍼티를 참조해야하면 정적 매서드 대신 프로토타입매서드를 사용해야한다. 

**정적 매서드와 프로토타입 매서드의 차이**

1. 프로토타입 체인이 다르다
2. 정적 매서드는 클래스로 호출, 프로토타입 매서드는 인스턴스로 호출
3. 정적 매서드는 인스턴스 프로퍼티 참조 불가능, 프로토타입 매서드는 가능
4. this 바인딩이 다르다. 프로토타입 매서드는 인스턴스로 호출해야하므로 this는 프로토타입 매서드를 호출한 인스턴스 가리침
    
    정적 매서드는 클래스 호출이므로 정적 매서드 내부의 this는 인스턴스가 아닌 클래스를 가리킴
    
5. this를 사용해야하면 프로토타입 매서드로, this를 사용하지 않는다면 정적 매서드로 정의하는 게 좋다

표준 빌트인 객체인 Math, Number, JSON, Object, Reflect 등은 다양한 정적 매서드를 가지고 있다. 앱 전역에서 사용할 유틸리티 함수다. (ex Math.max())