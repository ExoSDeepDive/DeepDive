# 24장 클로저 (closure)

### 클로저(closure)

- 함수[반환된 내부 함수]와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical Environment)[함수가 선언됐을 때의 스코프]
- 자신을 포함하고 있는 외부 함수보다 내부 함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부 함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는 함수
- 렉시컬 스코핑(Lexical Scoping) : 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 스코프가 결정됨

### 클로저의 활용

1. 상태 유지 - 현재 상태를 기억하고 변경된 최신 상태를 유지
2. 전역 변수의 사용 억제
3. 정보의 은닉

# 25장 클래스 (class)

### 클래스(class)
- 클래스 선언문 이전에 참조 불가, let/const 키워드로 선언한 변수처럼 호이스팅
- 클래스 몸체(class body)에는 메소드만 선언 가능, 클래스 필드 선언하면 문법 에러 발생
- 클래스 필드의 선언과 초기화는 반드시 constructor 내부에서 실시 -> construnctor 내부에서 선언한 클래스 필드는 언제나 public

### getter
- 클래스 필드에 접근할 때마다 클래스 필드의 값을 조작하는 행위가 필요할 때 사용
- 호출하는 것이 아닌 참조 형식으로 사용
- 반드시 반환값 필요

### setter
- 클래스 필드에 값을 할당할 때마다 클래스 필드의 값을 조작하는 행위가 필요할 때 사용
- 호출이 아닌 할당 형식으로 사용

### 정적 메소드
- static 키워드로 정의
- 클래스의 인스턴스가 아닌 클래스 이름으로 호출

### 클래스 상속
1. extends 키워드 - 부모 클래스를 상속받는 자식 클래스를 정의할 때 사용
2. super 키워드 - 부모 클래스를 참조할 때 또는 부모 클래스의 constructor를 호출할 때 사용
3. static 메소드와 prototype 메소드의 상속 - 자식 클래스는 프로토타입 체인에 의해 부모 클래스의 정적 메소드 참조 가능, 자식 클래스의 인스턴스는 프로토타입 체인에 의해 부모 클래스의 정적 메소드 참조 불가 


