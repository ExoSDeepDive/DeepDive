> Q. 다음 코드의 결과는?
  ```javascript
    var obj1 = { foo: 'bar', x: 42 };
    var obj2 = { foo: 'baz', y: 13 };
    const merge = ( ...objects ) => ( { ...objects } );

    var mergedObj1 = { ...obj1, ...obj2 };
    var mergedObj2 = merge( obj1, obj2);
    var mergedObj3 = merge( {}, obj1, obj2);
    var mergedObj4 = Object.assign( obj1, obj2);
    var mergedObj5 = Object.assign( {}, obj1, obj2);

    console.log(mergedObj1, mergedObj2, mergedObj3, mergedObj4, mergedObj5);
  ```

# 34. 이터러블
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;├─ 이터러블: `Symbol.iterator` 메서드 갖는 순회가능한 객체<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`for ... of`로 순회, 스프레드 문법 & 배열 디스트럭처링 할당 가능<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─ 이터레이터: 이터러블을 탐색하기 위한 포인터 역할<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이터러블의 `Symbol.iterator` 호출하면 이터레이터 리턴, 이터레이터의 `next`메서드 호출하면 이터레이터 리절트 객체(`{value, done}`) 리턴<br>
- js 빌트인 이터러블: `Array`, `String`, `Map`, `Set`, `TypedArray`, (`arguments`, `NodeList`, `HTMLCollection` - 이터러블이면서 유사 배열 객체)
- `for(`변수선언 `of` **이터러블**`)`&nbsp;&nbsp;&nbsp;<-> `for (`변수선언 `in` **객체**`)`<br>
└>이터레이터 리절트 객체의&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└> `[[Emerable]]`=`true`인 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`done`=`false`이면 순회&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;프로퍼티만 순회(키가 심벌이면 제외)
- 유사 배열 객체: `length` 프로퍼티 갖고 키를 인덱스처럼 쓸 수 있는 객체 -> `for`문은 가능, `for ... of`는 불가능(`Symbol.iterator` 없음)
- 이터러블/유사 배열 객체 -> 배열 : `Array.from()`
- 이터레이션 프로토콜이 있으면 데이터 소비자(`for ... of`, 스프레드, 배열 드스트럭처링 할당)는 이것만 지원하도록 구현하면 됨 -> 데이터 소비자-데이터 공급자를 연결하는 인터페이스 역할
- `Symbol.iterator` 메서드 갖고 `Symbol.iterator`가 리턴하는 `next` 메서드가 이터레이터 리절트 객체 리턴하게 정의하면 사용자 정의 이러터블이 됨
- 이터러블이면서 이터레이터일 수도 있음
  ```javascript
  {
    [Symbol.iterator]() { return this; },
    next() { return {value: any, done: boolean} }
  }
  ```
- `done` 생략하면 무한 이터러블 가능 (무한 수열)
- 지연 평가: 원래 배열이나 문자열은 모든 데이터를 미리 메모리에 확보해뒀다 공급하는데 이터러블은 데이터가 필요할 때 바로 평가해서 공급하는 것(순회할 때마다 `next` 메서드가 호출되면서 생성) => 실행 속도 빠름 & 불필요한 메모리 소비X & 무한대 표현 가능

<br><br>

# 35. 스프레드 문법
- 이터러블만 스프레드 문법 사용 가능
- 스프레드 문법은 연산자가 아니기 때문에 변수에 할당할 수 없음 -> 함수 매개변수, 배열/객체 리터럴 생성 시에만 사용 가능
- 스프레드 문법(배열을 펼쳐서 개별로 만들기) <-> Rest 파라미터(매개변수를 합쳐 배열로 만들기)
  ```javascript
  const func = (...rest) => { } // Rest 파라미터
  func(...[a, b])               // 스프레드 문법
  ```
### 활용
```javascript
// concat 없이 배열 합치기
const arr = [...[1,2], ...[3,4]];

// 배열에 다른 배열 원소 추가 (그냥 배열 전달하면 중첩 배열 생성)
arr.splice(1, 0, ...arr1);

// slice 없이 배열 복사 (얕은 복사)
const copy = [...arr];

// apply/call 없이 이터러블->배열 변환 (유사 배열 객체는 불가, Array.from 사용)
const func = () => [...arguments].reduce(); 
// rest 파라미터가 더 좋은 방법
const func2 = (...args) => args.reduce();

// Object.assign 없이 객체 복사/병합 (ECMA 2018)
const obj = { x:1, ...{ y: 2, z: 3 } };
```


┌<br>├<br>└<br>│<br>│