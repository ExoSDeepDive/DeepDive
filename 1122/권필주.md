🔐 개념 숙지

> - 일급객체
> - 함수 호이스팅과 변수 호이스팅의 차이
> - 객체의 깊은 복사 필요한 이유와 방법
> - 콜백함수
> - 고차함수
> - 렉시컬 환경
> - 렉시컬 스코프
> - 스코프 체이닝

💡생각해보기

> ## Quiz 1
* to do 앱을 만들고자 한다. 
```
#App.js

import React, {useState} from 'react';
import Todo from "./todo";
import TodoForm from "./TodoForm";

function App() {

    const [todo, setTodo] = useState(    [{
            text: "Upload the video by tonight",
            hasCompleted: false,
        }]);
    
    const completeTodo = (index) => {
    setTodo( (current)=>{
        const todo = [...current];
        todo[index].hasCompleted = true;
        return todo;
        })};
```
그리고 완료 버튼 스타일에는 다음과 같이 설정했다고 하자
```
 style={{ textDecoration: todo.hasCompleted ? "line-through" : "none" }}
 ```

 질문 : 완료 버튼을 누르면 취소선이 그어지는지 여부와 그 이유를 설명하세요.

 > ## Quiz 2
다음의 실행 결과는? 

```jsx
function repeat(n,f){
	for (var i = 0; i < n; i++){
		f(i);
}
}

var logOdds = function (i) { 
	if (i % 2) console.log(i); 
}; 

repeat(5, logOdds());
```

> 

## 11장. 원시값과 객체의 비교

| 원시타입                     | 객체타입                           |
| ---------------------------- | ---------------------------------- |
| primitive type               | object/reference type              |
| 단 하나의 값만 나타냄        | 복합적인 자료구조                  |
| 변경 불가능 immutable value  | 변경 가능한 값 mutable value       |
| read only                    |                                    |
| 메모리에 실제 값 저장        | 메모리에 참조값 저장               |
| 값에 의한 전달 pass by value | 참조에 의한 전달 pass by reference |

### 원시값

#불변성 #값에 의한 전달

- 원시값은 어떤 일이 있어도 불변하므로 예기치 못한 변경으로부터 자유롭고 이는 데이터의 신뢰성을 보장한다.

- 어떤 변수에 원시값을 갖는 변수를 할당하면 원시값이 복사되어 전달된다

- 값에 의한 전달이란 어떤 변수에 원시값을 갖는 변수를 할당하면 원시값이 복사 사되어 전달되는 것을 의미한다. 

cf. 파이썬  
원시값이 복사되는게 아니라 두 변수가 같은 원시값을 참조하다가 다른 변수에 재할당이 이루어지면 새로운 메모리 공간에 저장한다

### 객체

#mutable value #히든 클래스 #참조에 의한 전달
* JS에서 객체는 비싼 연산이다. v8엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 dynamic lookup 대신 히든 클래스 hidden class라는 방식을 사용해 C++ 정도의 성능을 보장한다.   
* 변경 가능한 값이란 원시값과는 달리 객체는 메모리에 저장된 객체를 직접 수정할 수 있다는 의미이다. 참고로 객체를 할당한 변수는 재할당이 일어나지 않으면 참조값은 변경되지 않는다.
* 참조에 의한 전달이란 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 봉사되어 전달되는 것을 의미한다.

### 정리

원시타입은 메모리 공간에 원시값이 저장되고 객체타입은 메모리 공간에 참조값이 저장된다.

복사가 일어날때 객체 타입은 얕은 복사가 일어나 주소값만 참조하고 있다. 따라서 복사한 값의 프로퍼티 값을 변경하면 원본 객체의 값도 바뀐다.

원본 객체의 값을 변경시키지 않고 복사한 객체의 프로퍼티 값만 변경하는 방법 중 하나가 spread operator(`…`) 이다.

## Quiz
* to do 앱을 만들고자 한다. 
```
#App.js

import React, {useState} from 'react';
import Todo from "./todo";
import TodoForm from "./TodoForm";

function App() {

    const [todo, setTodo] = useState(    [{
            text: "Upload the video by tonight",
            hasCompleted: false,
        }]);
    
    const completeTodo = (index) => {
    setTodo( (current)=>{
        const todo = [...current];
        todo[index].hasCompleted = true;
        return todo;
        })};
```
그리고 완료 버튼 스타일에는 다음과 같이 설정했다고 하자
```
 style={{ textDecoration: todo.hasCompleted ? "line-through" : "none" }}
 ```

 질문 : 완료 버튼을 누르면 취소선이 그어지는지 여부와 그 이유를 설명하세요.

<br>

## 12장. 함수

### 함수 정의

JS 엔진이 평가하여 함수 객체가 될 수 있도록 함수 호출 이전에 매개변수, 문, 반환 값을 지정하는 것.

4가지 방법 있음

1. 함수 선언 방식
    * 함수 리터럴과 동일한 형태. 단, 함수 리터럴과는 달리 함수 선언문은 함수 이름을 생략할 수 없다.
    * 함수 선언문은 표현식이 아닌 문이다
2. 함수 표현식
    * 함수의 일급객체 성질 이용해 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있는 함수 정의 방식
    * 함수의 호출은 함수 이름이 아니라 함수 객체를 가리키는 식별자로 호출한다.
    * ### 함수 생성 시점과 함수 호이스팅

    **함수호이스팅 function hoisting**

    함수 선언문으로 정의한 함수는 런타임 이전에 JS 엔진에 의해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당하므로 함수 선언문 이전에 참조하거나 호출 할 수 있다. 

    cf 함수 호이스팅 vs 변수 호이스팅

    생성 시점이 선언 이전이라는 점은 동일하지만 var로 선언된 변수는 undefined로 초기화되고 함수 선언문으로 생성된 식별자는 함수 객체로 초기화된다. 따라서 선언 이전에 변수를 참조하면 undefined로 평가되고 함수를 호출하면 호출이 가능하다.

    함수 표현식으로 정의하고 변수에 할당하면 변수 선언은 런타임 이전에 실행되고 undefined로 초기화되고 할당문은 실행되는 시점인 런타임에 평가되므로 이때 평가되어 함수 객체가 된다.

    따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다. 따라서 함수 표현식으로 정의한 함수를 표현식 이전에 호출하면 undefined로 반환되고 타입에러 발생한다. 따라서 반드시 함수 표현식 이후에 참조 또는 호출해야한다.
3. Function 생성자 함수
    * 사용 비추
4. 화살표 함수
    * 26장 참고

### 함수 호출

함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.

### 참조에 의한 전달과 외부 상태의 변경

매개변수도 함수 몸체 내부에서는 변수와 동일하게 취급되므로 매개변수의 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따른다. 

매개변수가 하나는 원시값이고 하나는 객체라면 각각 값 자체, 참조값이 복사되어 전달되므로 외부 상태에서 매개변수의 변경이 있을때 원시값은 원본이 훼손되지 않고 객체는 원본이 훼손된다. 

함수가 가령 객체인 매개변수를 받고 그 전달받은 객체에 변경을 가하면 외부상태인 그 객체의 상태변화를 추적하기 힘들다. 객체는 변경할 수 있는 값이고 참조에 의한 전달 방식으로 동작하기 때문에 발생하는 부작용이다. 

해결 방법

- 객체의 변경을 추적하기 위해 옵저버 패턴을 사용
- 객체를 불변 객체로 만들어 사용하기도 한다. 객체의 복사가 필요한 경우 ***깊은 복사***를 통해 새로운 객체 생성하고 재할당 통해 교체함으로써 외부 상태가 변경되는 부수효과 제거 가능

#깊은 복사를 하는 방법
1. JSON.parse(JSON.stringify()) 활용
```
let ingredients_list = ["noodles", { list: ["eggs", "flour", "water"] }];
let ingredients_list_deepcopy = JSON.parse(JSON.stringify(ingredients_list));
```
2. 커스텀 재귀 함수 사용
```
function cloneObject(obj) {
  var clone = {};
  for (var key in obj) {
    if (typeof obj == "object" && obj[key] != null) {
      clone[key] = cloneObject(obj[key]);
    } else {
      clone[key] = obj[key];
    }
  }

  return clone;
}
```
3. lodash의 cloneDeep() 사용


**콜백함수**

callback function

함수의 매개변수를 통해 다른 함수의 내부오 전달되는 함수 

**고차함수**

higher-order function, HOF

매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수

**순수 함수와 비순수 함수**

pure function, impure function

부수효과가 없는 함수(어떤 외부상태에 의존하지도, 변경하지도 않는 함수)가 순수 함수.
함수형 프로그래밍은 순수 함수 통해 부수 효고 억제하려는 패러다임이다.
인수의 불변성에 의존하므로 객체를 전달받으면 비순수함수가 된다. 


## Quiz
다음의 실행 결과는? 

```jsx
function repeat(n,f){
	for (var i = 0; i < n; i++){
		f(i);
}
}

var logOdds = function (i) { 
	if (i % 2) console.log(i); 
}; 

repeat(5, logOdds());
```

→ 1,3이 아님.

왜? 고차함수에 콜백함수는 호출하지 않고 함수 자체를 전달해야하기 때문

<br>

## 13장. 스코프
**렉시컬 환경**

lexical environment

코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 가리키는 말

"lexical"이란, 어휘적 범위 지정(lexical scoping) 과정에서 변수가 어디에서 사용 가능한지 알기 위해 그 변수가 소스코드 내 어디에서 선언되었는지 고려한다는 것을 의미한다. - [MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures)

**컨텍스트**

context

코드의 문맥

렉시컬 환경으로 이루어짐

이를 구현한 것이 실행 컨텍스트 execution context

**전역스코프**

global scope

어디서든 참조 할 수 있음

**지역스코프**

local scope

지역이란 함수 몸체 내부 의미

## 14장. 전역변수의 문제점
### 지역 변수의 생명 주기
1. 함수 내부에서 선언된 지역변수는 함수가 생성한 스코프(→ 렉시컬 스코프)에 등록됨

2. 변수는 자신이 등록된 스코프가 소멸(메모리 해제)될때까지 유효

3. 누군가 스코프 참조하고 있으면 소멸하지 않고 생존한다

4. 호이스팅은 스코프를 단위로 동작

### 전역변수의 생명주기
전역 객체의 생명 주기와 일치

### 전역 변수의 문제점

1. 암묵적 결합
    
    implilcit coupling
    
    모든 코드가 전역 변수 참조하고 변경할 수 있음
    
2. 긴 생명 주기
    
    생명 주기가 길기때문에 메모리 리소스 소비 시간도 길다.
    
    변수 이름이 중복되면 의도하지 않은 재할당이 이루어지기도 한다
    
3. 스코프 체인 상의 종점에 존재
    
    변수를 검색할 때 전역 변수가 가장 마지막에 검색 → 전역 변수의 검색 속도가 가장 느리다.
    
4. 네임스페이스 오염
    
    파일이 분리되어 있어도 하나의 전역 스코프 공유하므로 다른 파일 내 동일 이름 변수나 함수가 같은 스코프에 존재하면 예상치 못한 결과 가져올 수 있음
    

### 전역 변수 사용 억제 방법

변수의 스코프는 범위가 좁을수록 좋다

1. 즉시함수 실행  
즉시실행함수는 객체를 반환하는데 이때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버임 → 외부 노출하고 싶지 않으면 클로저 활용해야함
2. 네임스페이스 객체
    
    네임스페이스역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가
    
    네임스페이스 객체 자체가 전역변수에 할당되므로 그다지 유용하지는 않음
    
3. 모듈 패턴
    
    클로저를 통해 전역 변수 억제. 캡술화(객체 프로퍼티와 메서드를 하나로 묶는 것)도 구현 가능
    
    JS는 접근 제한자 제공하지 않는데 모듈 패턴으로 한정적이지만 접근 제한 기능 구현 가능
    
4. ES6 모듈
    
    ES6모듈은 파일 자체의 독자적인 모듈 스코프 제공하므로 var 키워드로 선언한 변수도 더이상 전역 변수가 아니고 window 객체의 프로퍼티도 아님.
    모던 브라우저에서 사용 가능.

    브라우저의 ES6모듈 기능 사용하더라도 트랜스 파일링, 번들링 필요한데 아직은 Webpack등의 모듈 번들러 사용하는 것이 일반적임