# 2. 자바스크립트의 특징

- 웹 브라우저에서 동작하는 유일한 언어
- 인터프리트 언어: 런타임에 한 줄씩 바이트코드로 변환해서 실행, 느림(<->컴파일러 언어: 컴파일 타임에 코드 전체를 머신코드로 변환)<br/>
  => 명시적으로 컴파일 타임이 있진 않지만 일부 코드를 미리 컴파일해서 속도 높임
- 멀티 패러다임 프로그래밍 언어: 명령형/함수형/프로토타입/객체지향
- 브라우저는 DOM API 제공, 파일시스템 미제공<br/>Node.js는 DOM API 미제공, 파일시스템 제공
  <br/><br/>

# 4. 변수

- 변수(식별자): 값을 저장할 때 그 **메모리 공간의 주소**에 붙인 이름
- 값 저장은 할당, 부르는건 참조
- 선언: 메모리공간 만들고 이름-주소 연결, 할당: 저장, 참조: 불러오기
  - 선언 = 선언 단계(js 엔진에 이름 등록) + 초기화 단계(메모리 공간 만들고 `undefined`로 초기화)
- 선언 없이 참조하면 ReferenceError
- 호이스팅: 변수 선언이 런타임 전에 일어나서 선언문이 맨 위로 끌어올려진 것 같은 현상
- 할당할 때는 이전 값 들어있던 메모리 주소에 새로운 값을 넣는 게 아니라 새로운 메모리 공간에 값을 넣고 참조 주소를 그쪽으로 바꿈
- 참조되지 않는 값은 가비지 콜렉터가 찾아서 메모리 공간 해제함(매니지드 언어)
- 네이밍 규칙: `_$` 제외한 특수문자 불가, 숫자로 시작 불가<br/><br/>

# 5. 표현식과 문

- 값: 표현식이 평가된 결과
- 문(=명령문): 프로그램 구성 기본 단위이지 최소 실행 단위(; or { } 하나)
- 토큰: 문법적 최소 단위(단어 하나)
- 표현식: 값으로 평가될 수 있는 문(함수 호출도 표현식)
- 리터럴: 사람이 이해할 수 있는 글자로 값을 생성하는 표기법
- 표현식인 문은 평가된 값 반환, 표현식이 아닌 문은 **완료값** `undefined` 반환 (할당/참조 불가)
  - 변수에 할당할 수 있으면 표현식인 문<br>
    -> 선언문 = 표현식인 문 `var a`<br> &nbsp;&nbsp;&nbsp;&nbsp; 할당문 = 표현식이 아닌 문 `a = 10`<br>&nbsp;&nbsp;&nbsp;&nbsp;
    선언문+할당문 = 표현식이 아닌 문 `var a = 10`
    <br><br>

# 6. 데이터 타입

- 원시 타입: 숫자/문자열/불리언/undefined/null/심벌<br>객체 타입: 객체/함수/배열
- 자바스크립트는 객체 기반 언어
- 자바스크립트는 어떤 진수로 써도 10진수로 해석됨
- `Infinity`, `-Infinity`, `NaN`
- `undefined`는 var 초기화 할때만 암묵적 할당, 사람이 할당할때는 `null` 사용
----
### 심벌

- 변경 불가, 다른 값과 중복되지 않는 유일한 값
- 객체의 유일한 key값 만들 때 사용
- `Symbol()`로 생성
- 생성된 값은 외부에 노출되지 않음
----
- 심벌 테이블: 식별자에 바인딩된 메모리 주소, 타입, 스코프 관리하는 자료구조
- 데이터 타입을 정하는 이유: 저장/참조할 때 메모리 공간 크기 필요, 2진수 해석할 때 필요
- 자바스크립트는 동적 타입 언어(<-> 정적 타입 언어: 명시적 타입 선언+컴파일때 타입 체크), 유연성↑ 신뢰성↓<br>=>타입 추론(선언이 아니라 할당에 의해 타입 결정)

# 7. 연산자

### +

- 일반적으로는 덧셈
- 숫자 타입이 아닌 값에 `+` 붙이면 숫자로 변환해서 리턴 (`-`는 - 붙여서 리턴)
  - `1 + true`는 1+1=2<br>`+null`은 0
- 피연산자 중에 문자열이 있으면 문자열 연결
(`+`를 제외한 산술 연산자는 문자열이 있어도 숫자로 변환)
----
- NaN은 자기 자신과 같지 않음
  ```javascript
  NaN === NaN;         // false
  Number.isNan(NaN);   // true
  Object.is(NaN, NaN); // true

  0 === 0;             // true
  Object.is(0, -0);    // false
  ```
- `!`이나 삼항 연산자 조건식은 불리언으로 암묵적 타입 변환
- `,`로 연결하면 앞에서부터 평가해서 마지막 평가 리턴
- `NaN`은 `number` 타입, 정규식/클래스는 `Object` 타입
- `typeof null`은 `Object`임(버그) => `typeof` 말고 `===`로 체크하기
- 선언 안 된 변수 `typeof`하면 `ReferenceError` 아니라 `undefined`
- `a ** b` = `Math.pow(a, b)` (ES7)

# 8. 조건문
- `if`/`while`의 조건식은 암묵적으로 불리언 타입으로 변환
- 폴스루: `switch`문에서 `break`를 안 해서 이후의 `case`문을 실행하는 것<br>-> 실행문 같은 것끼리 묶어서 `case:` 연달아서 쓰는 것도 폴스루
- 레이블문/반복문/`switch`문 이외에서 `break` 쓰면 `SyntaxError`
- 중첩 `for`문에서 바깥쪽 `for`에 레이블을 붙여서 안쪽 `for`에서 외부 `for` 탈출 가능
- `for`문 내부 `if`문 내에서 수행되는 코드가 길면 반대 조건 `if`에 `continue`로 바꿔서 indent 줄이기
<br><br>
>Q. `var foo = 10`은 선언문이자 할당문이라서 표현식인 문인데 왜 콘솔 찍으면 `undefined` 리턴? (58p.)<br><br>
A. 선언문 = 표현식인 문<br>
&nbsp;&nbsp;&nbsp;&nbsp;할당문 = 표현식이 아닌 문<br>
&nbsp;&nbsp;&nbsp;&nbsp;선언문+할당문 = 표현식이 아닌 문 &nbsp;&nbsp;&nbsp;&nbsp;이라서 완료값이 돼서 `undefined`<br>
&nbsp;&nbsp;&nbsp;&nbsp;+) `return` 뒤에 넣을 수 있으면 표현식인 문, 없으면 표현식이 아닌 문