🔐 개념 숙지
> - constructor / non-constructor 구분
> - JS의 배열을 한 줄로 개념 정리
> - 배열의 생성방법 4가지



💡생각해보기

> ## Quiz 1. 
> 다음 코드에서 예상되는 출력은?
```jsx
const arr = [1,2];
console.log(arr[2]); //?
```

> ## Quis 2.배열 활용
> 아래 코드는 setPoll함수의 일부이다. pro, con, neu 란 변수 셋 중 하나는 boolean 값이 들어있다. 그러나 프론트가 보내는 pollData에서 어떤 변수에 값이 들어있을지는 알 수 없다. 이들 변수의 유효성을 검증하는 if 조건식을 배열을 이용해 완성하세요. 

```jsx
async setPoll(pollData: AddPollDto, issueId) {

    const { userId, pro, con, neu } = pollData;
    if ( condition ){
        throw new Error('invalid poll')
    }

    ...

}
```

## 26장. ES6 함수의 추가 기능
### 함수의 구분

ES6이전까지 사용목적에 따라 명확한 구분 없이 모든 함수는 일반함수로 호출할 수 있으면서 동시에 생성자 함수로 호출할 수 있었다.

심지어 객체에 바인딩된 함수도 생성자 함수로 호출하는 것이 문법상 가능했으므로

즉, 객체에 바인딩된 함수도 constructor라는 것은 객체에 바인딩된 함수가 prototype 프로퍼티를 가지고 프로토타입 객체도 생성한다는 것을 의미한다. 콜백함수도 constructor이므로 불필요한 프로토타입 객체를 생성한다.

생성자 함수로 호출하지 않아도 프로토타입 객체를 생성한다는 것은 혼란스럽고 실수 유발 가능성 높고 성능 문제 있었다. 

ES6에서는 함수를 자세히는 5가지 크게는 3가지로 구분한다.

### 매서드

**ES6 사양에서 매서드는 객체에 바인딩되었을 뿐 아니라 매서드 축약 표현으로 정의된 함수만을 의미**.

객체에 바인딩되었으나 매서드 축약 표현이 아니라 function 키워드로 일반함수로 쓰면 이는 매서드가 아니라 그냥 일반함수다. 이 함수는 객체에 바인딩 되어 있어도 constructor이고 prototype프로퍼티가 있고 프로토타입도 생성한다.

인스턴스를 생성할 수 없는 non-constructor이다. 따라서 생성자 함수로서 호출할 수 없다.

인스턴스 생성할 수 없으므로 prototype 프로퍼티가 없다

표준빌트인 객체가 제공하는 프로토타입 매서드와 정적 매서드는 모두 non-constructor이다.

매서드는 자신을 바인딩한 객체를 가리키는 내부슬롯 [[HomeObject]]를 가지고 이를 통해 super 참조 가능하다.

ES6 매서드가 아닌 함수는 super 키워드를 사용할 수 없다.

ES6 매서드는 본연의 기능인 super를 추가하고 의미적으로 맞지 않는 constructor는 제거했다.

### 화살표 함수

- 함수 선언문으로 정의할 수 없다 → 함수 표현식으로 정의해야한다
- 매개변수가 하나면 소괄호()를 생략할 수 있다
- 매개변수가 없는 경우 소괄호를 생략할 수 없다
- 함수 몸체가 하나의 문이면 중괄호{}를 생략할 수 있다
    - 함수 몸체 내부의 문이 표현식이 아닌 문이라면 중괄호 생략할 수 없다.
- 객체 리터럴을 반환하는 경우 소괄호()로 감싸주어야 한다
    - 감싸지 않으면 함수 몸체를 감싸는 중괄호로 해석하기 때문이다
    
    ```jsx
    const create = (id, content) => ({id, content});
    
    //다음과 같다
    const create = (id, content) => { return {id, content};};
    ```
    
- 함수 몸체에 문이 여러개라면 중괄호 {} 생략할 수 없고 반환값이 있다면 명시적으로 반환해야한다
- 화살표함수도 즉시실행함수로 사용할 수 있다
- 화살표 함수도 일급객체이므로 고차함수에 인수로 전달할 수 있다

**일반함수와의 차이**

1. non-constructor이다
    1.  인스턴스 생성할 수없다
    2. 생성자함수로 호출할 수 없다
    3. prototype프로퍼티 없고 프로토타입도 생성하지 않는다 
2. strict mode가 아니라도 중복된 매개변수 이름을 선언할 수 없다
3. 자체의 this, arguments, super, [new.target](http://new.target) 바인딩을 갖지 않는다.

**this**

결정적 차이가 this 바인딩이다.

this는 함수 호출에 따라 동적으로 결정된다. 렉시컬 스코프가 함수 정의 위치에 따라 정적으로 결정되는 것과 대조적이다.

<br>

## 27장. 배열
- JS의 배열은 배열이란 별도의 타입이 존재하지 않는다. 배열의 타입은 객체이다.
- 자료구조에서 배열은 요소를 위한 동일한 크기의 메모리 공간에 하나의 데이터 타입이 빈틈없이 연속적으로 나열되어있는(→ 밀집 배열) 자료구조이다.
    - 밀집 배열의 임의 접근 시간 복잡도는 O(1)로 성능이 매우 좋다
    - 정렬되지 않은 배열에서의 선형 검색 시간복잡도는 O(n)
    - 요소 삽입, 삭제시 배열 요소 이동시켜야함
- JS의 배열은 자료구조로서의 배열과 달리 메모리 공간이 동일한 크기 가지지 않아도 되고, 비연속적이어도 된다. (→ 희소배열)
    - JS의 배열은 인덱스를 나타내는 문자열을 프로퍼티 키로 가지며, length 프로퍼티를 갖는 특 수한 객체다.
    - JS의 모든 값은 배열의 요소가 될 수 있다
    - JS의 배열은 요소 접근시 일반 배열보다 느림(해시테이블 구조)
    - 요소 삽입, 삭제의 경우 일반 배열보다 빠름
    - JS의 배열 객체는 일반 객체보다 약 2배 정도 빠름

### **배열의 생성**

1. 배열 리터럴 `[]`
2. Array 생성자 함수
    1. 전달된 인수가 양의 정수 하나면 length 프로퍼티값이 인수인 배열(실제 요소는 없는 희소배열) 생성
    2. 배열 최대 길이 초과하거나 음수가 인수로 전달되면 RangeError 
    3. 전달된 인수가 없으면 빈 배열 생성
    4. 전달된 인수가 2개 이상의 숫자나 숫자가 아닌 경우(가령, 빈 객체 {}) 그 인수를 요소로 갖는 배열 생성
3. Array.of
    1. 전달된 인수를 요소로 갖는 배열 생성
    2. 전달된 인수가 숫자 하나라도 그 인수를 요소로 갖는 배열 생성.
    
    ```jsx
    Array.of(1); // [1]
    ```
    
4. Array.from
    1. 유사배열 객체나 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환
        
        ```jsx
        const str = 'banana';
        const arr = Array.from(str);
        console.log(arr); // 
        ```
        
    2. **유사배열객체** array-like object
        
        인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체
        
        스프레드 문법 대상 아니다
        
    3. **이터러블객체** iterable object
        
        Symbol.iterator 매서드를 구현해 `for .. of` 문으로 순회할 수 있고 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있는 객체를 말한다. 
        
    
    [iterable](https://www.notion.so/iterable-9cfd5bb05f6f4867ab6424b3b101547b)
    

### 배열 요소의 참조

대괄호 표기법([]) 사용

인덱스는 정수로 평가될 수 있는 표현식이어야 함

존재하지 않는 요소에 접근하면 undefined 반환

*이는 배열이 문자열을 프로퍼티 키로 갖는 객체이기 때문

존재하지 않는 객체의 프로퍼티에 접근하면 undefined 반환하는 것과 같은 원리임

- 퀴즈
    
    setPoll 함수의 변수 유효성 검증
    

delete 연산자는 희소배열 만들기 때문에 비추

배열 특정 요소 완전삭제는 Array.prototyep.splice 사용 권장
