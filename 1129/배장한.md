# 15장 - var, let, const

|  | var | let | const |
| --- | --- | --- | --- |
| 변수 중복 선언 | O | X | X |
| 재할당 가능 여부 | O | O | X 
하지만 객체는 값 변경 가능. 원래 객체 자체가 변경이 가능한 참조값이기 때문. |
| 블록 레벨 스코프 | 함수 스코프만 인정 | 모든 코드 블록 스코프 | 모든 코드 블록 스코프 |
| 변수 호이스팅 | 선언과 초기화 동시에 | 선언과 초기화 분리 
⇒ 일시적 사각지대 존재
⇒ 호이스팅은 이루어지지만 초기화가 되지 않아 ReferenceError 발생 | 선언과 초기화 동시에. var와 달리 선언 시 값을 반드시 할당해야 함 |
| 전역 객체와의 관련성 | window 객체의 프로퍼티 | 보이지 않는 전역 개념적 블록 내에 존재 |  |

# 16장 - property attribute

1. 내부 슬롯과 내부 메서드: 자바스크립트 엔진의 내부 로직으로 간접적으로만 접근할 수 있음.
    1. [[Prototype]] 내부 슬롯은 .__proto__로 접근 가능
2. 프로퍼티 어트리뷰트: 프로퍼티의 상태를 나타냄
    1. 데이터 프로퍼티
        1. value: 키에 접근하면 반환되는 값
        2. writable: value 변경 가능 여부
        3. enumerable: 열거 가능 여부
        4. configurable: 프로퍼티 속성의 변경 가능 여부
    2. 접근자 프로퍼티
        1. get: 프로퍼티의 값을 읽을 수 있는 함수
        2. set: 프로퍼티의 값을 설정할 수 있는 함수
3. 프로퍼티 디스크립터: 프로퍼티 어트리뷰트의 정보를 제공하는 객체
    1. `Object.getOwnPropertyDescriptor(s)`
4. 프로퍼티 정의 방법
    1. `Object.defineProperty(객체, 프로퍼티 이름, 프로퍼티 어트리뷰트 객체)`
5. 객체 변경 방지 ( PASS )
    1. 객체 확장 금지
    2. 객체 밀봉
    3. 객체 동결
    4. 불변 객체

# 17장 - 생성자 함수

1. 생성자 함수의 사용성
    1. 객체 리터럴로 프로퍼티 구조가 동일한 객체를 생성하려면 같은 리터럴을 반복해야 함.
    2. 생성자 함수는 템플릿으로 인스턴스를 찍어낼 수 있어서 높은 사용성.
2. 함수의 호출 방식에 따른 this 바인딩
    1. 요약
        
        
        | 일반 함수 | 전역 객체, 또는 해당 스코프 |
        | --- | --- |
        | 메서드 | 메서드를 보유한 객체 |
        | 생성자 함수 | 생성될 인스턴스 |
    2. 생성자 함수의 인스턴스 생성 방식
        1. 암묵적으로 인스턴스 생성 후 this에 바인딩
        2. this.property를 통해 인스턴스를 초기화
        3. return문이 없으면 암묵적으로 this를 반환함 ⇒ 인스턴스가 리턴됨
            1. return을 통해 명시적으로 객체를 리턴하면 this가 무시됨
            2. 하지만 원시값을 리턴하면 원시값이 무시됨.
                
                ```jsx
                function Test(value) {
                    this.test = value;
                    return 100;
                }
                
                const contructor = new Test(1);
                console.log(contructor); // Test { test: 1 }
                
                const value = Test(1);
                console.log(value); // 100
                ```
                
            3. 결론: 생성자함수로 쓰려면 **return문을 반드시 생략하자.**
    3. 생성자 함수의 작동 원리
        1. 함수 객체는 [[Call]], [[Constructor]]라는 두 내부 메서드를 갖고 있기 때문임.
        2. 모든 함수는 callable이지만 constructor는 아닐 수도 있음.
        3. 함수 정의 방식에 따라 constructor or non-constructor가 정해짐
            1. constructor: 함수 표현식, 함수 선언문, 클래스, 메서드(프로퍼티 값)
            2. non-constructor: 화살표 함수, 축약 메서드
        4. new를 붙여 호출할 때 해당 객체가 constructor인 경우에 생성자 함수로서 실행함.

# 18장 - 함수와 일급 객체

1. 함수 객체의 고유 프로퍼티
    1. arguments
        1. 인수가 초과되어도 arguments 객체 내에 보관됨. 
        2. 인자의 개수가 변화하는 함수를 구현할 때 유용하나, ES6 이후 rest parameter에 대체됨.
        3. Symbol.iterator 프로퍼티를 활용하여 객체에서 iterable 객체로 자료구조를 바꿀 수 있음.
    2. caller: 자신을 호출한 함수를 가리킴
    3. length: 매개 변수의 개수. 인자(argument)가 아님
    4. name: 함수의 이름, 식별자를 값으로 가짐
    5. prototype: 생성자 함수만이 가지는 프로퍼티로, 생성될 인스턴스의 프로토타입 객체를 가리킴
