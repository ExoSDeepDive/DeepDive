🔐 개념 숙지
> - 함수 레벨 스코프
> - 불변객체 만드는 방법 
> - 일급객체


💡생각해보기
> ## Quiz 1.


## 15장. 


## 16장. 프로퍼티 어트리뷰트
* 불변객체 만들기
    Object.freeze()활용해 재귀적으로 만들어 주기

```
function deepFreeze(target) {
if (target && typeof target === 'object' %% !Object.isFrozen(target)) {
	Object.freeze(target);
	Object.keys(target).forEach(key => deepFreeze(target[key]));
}
return target;
}

const person = {
name = 'Kwon',
address = { city: 'Seoul'}
};

//깊은 객체 동결
deepFreeze(person);

console.log(Object.isFrozen(person)); //true
console.log(Object.isFrozen(person.address)) //true

person.address.city = 'Ulsan';
console.log(person.address.city); // 'Seoul'
```
    
* cf. deep copy 방법

## 17장. 생성자 함수에 의한 객체 생성
* 객체 리터럴에 의한 객체 생성 방식의 문제점

    => 단 하나의 객체만 생성하므로 동일 프로퍼티를 갖는 객체를 여러개 생성해야하는 경우 비효율적이다.

* 생성자 함수에 의한 객체 생성 방식의 장점

    => 객체를 생성하기 위한 템플릿처럼 사용하면 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 만들 수 있다.

```
function Circle(radius){
	this.radius = radius;
	this.getDiameter = function () {
		return 2 * this.radius;
	};
}

const circle1 = new Circle(5);
const circle2 = new Circle(10);
```

**내부 메서드 [[call]]과 [[construct]]**

함수는 객체이므로 내부 슬롯과 내부 매서드를 모두 가지고 있다. 

함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 생성자 함 수로서 호출되면 내부 메서드 [[Construct]]가 호출된다.

[[Call]]을 가지는 함수 객체를 callable,

[[Construct]]를 가지는 함수 객체를 constructor,

[[Construct]]를 가지지 않는 함수 객체를 non-constructor 라고 부른다. 

JS 엔진은 함수 객체를 생성할때 함수 정의 방식에 따라 constructor와 non-constructor를 구분한다.

■ constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다) 

■ non-constructor: 메서드(ES6 메서드 축약 표현), 화살표 함수


* new 연산자로 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. [[Call]]이 아니라  [[Construct]]가 호출된다. 

* new 연산자 없이 함수를 호출하면 해당 함수는 일반 함수로 동작한다. [[Call]]이 호출된다.


## 18장. 함수와 일급 객체
* 일급객체의 특징

1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다. 
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다. 
3. 함수의 매개변수에 전달할 수 있다. 
4. 함수의 반환값으로 사용할 수 있다.

