🔐 개념 숙지

> - 항상 falsy한 값 6개
> - 함수의 매서드의 차이!


💡생각해보기

> - 다음 마지막 코드의 node.js 환경과 브라우저 환경에서의 해석
```
var person = {
'last-name':'Lee',
1:10
};
person.last-name //브라우저 환경과 node.js 환경의 해석이 다름!
```


## 9장. 타입변환과 단축평가
타입 변환 

- 명시적 타입 변환 explicit coersion= 타입 캐스팅 type casting   ⇒ 개발자의 명확한 의도
- 암묵적 타입 변환 implicit coersion = 타입 강제 변환 type coersion  ⇒ JS 엔진이 표현식 평가하면서 자동 변환. 개발자 의지와 상관없음.

항상 명시적 타입 변환이 옳을까? Nope! 가독성 면에서 암묵적 타입 변환이 더 좋고 코드를 예측할 수 있다면 암묵적 타입 변환을 사용하는 게 낫다.

`(10).toString()` 보다 `10 + ''` 이 더욱 간결하고 이해하기 쉽다.

### 암묵적 타입 변환

암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동변환한다.

- 문자열타입으로 변환
    - `+` 연산자
        - 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작
        - JS 엔진은 피연산자 중 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환 수행
        - 템플릿리터럴의 표현식은 평가 결과를 문자열 타입으로 암묵적 타입 변환
            
            ```jsx
            `1 + 1 = ${ 1 + 1}` 
            ```
            
            → 템플릿 리터럴안의 `1 + 1` 은 숫자로 계산되지 않고 문자열로 그대로 나타난다.
            
            따라서 위 식의 결과는 “ 1 + 1 = 2”
            
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4401e57a-d028-43f8-aaa2-23f414332ae4/Untitled.png)
        
- 숫자 타입으로 변환
    - JS 엔진은 **산술 연산자** 표현식을 평가 하기 위해 피연산자 중 숫자 타입이 아닌 경우 숫자타입으로 암묵적 타입 변환한다. 변환 할 수 없는 경우는 연산할 수 없으므로 NaN을 반환한다.
    - 비교연산자에 대해서도 마찬가지이다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/61a732f5-f59d-4ef8-89cd-ee28182a6ff3/Untitled.png)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5aa5ed94-bedd-4939-a993-bbb6b2ef339e/Untitled.png)
    
    빈 문자열 ( ' ' ) , 빈 배열 ( ) , null , false 는 0 으로 , true 는 1 로 변환 된다 . 객체 와 빈 배열 이 아닌 배열 , undefined 는 변환 되지 않아 NaN 이 된다는 것에 주의 하자 .
    
- 불리언 타입으로 변환
    - JS 엔진은 불리언 타입이 아닌 값을 Truthy, Falsy로 구분한다.
    - 자바 스크립트 엔진 은 불리언 타입 이 아닌 값 을 Truthy 값 ( 참 으로 평가 되는 값 ) 또는 Falsy 값 ( 거짓 으 로 평가 되는 값 ) 으로 구분 한다 . 즉 , 제어문 의 조건식 과 같이 불리언 값 으로 평가 되어야 할 문맥 에서 Truthy 값 은 true , Falsy 값 은 false 로 암묵적 타입 변환 된다 .
    
    ## 항상 falsy 한 값
    
    - false
    - 0, -0
    - `‘ ‘` 또는 `“ “`  (빈 문자열)
    - null
    - undefined
    - NaN
    
    이외의 값들은 모두 true로 평가되는 **Truthy** 값이다.
    
    **Falsy를 활용한 코드**
    
    falsy 앞에 `!`를 추가해주면 true로 전환
    
    ```jsx
    function print(person) {
      if (!person) {
        console.log('person이 없네요');
        return;
      }
      console.log(person.name);
    }
    
    const person = null;
    print(person);
    ```
    

### 명시적 타입 변환

- 문자열 타입으로 변환
    - 표준 빌트인 생성자함수(String, Number, Boolean)을 new 연산자 없이 호출하는 방법
        - `String(1)`
    - 빌트인 매서드 사용하는 방법
        - `(1).toString()`
    - 암묵적 타입 변환 이용하는 방법
    
- 숫자 타입으로 변환

## 단축평가

short circuit operator

1. `&&`
    1. 논리곱연산자
    2. 두 피연산자가 모두 true로 평가될때 두번째 피연산자를 그대로 반환한다.
2. `||`
    1. 논리합연산자
    2. 두 피연산자 중 하나만 true로 평가되어도 논리 연산의 결과를 결정한 첫번째 피연산자를 그대로 반환한다.

논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환하므로 단축 평가라 한다. 즉 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것이다. 

### 활용

1. 단축평가를 이용한 if문 대체.

→ 조건이 truthy일때 뭔가 해야한다면 `&&`

→ 조건이 falsy일떄 뭔가 해야한다면 `||`

1. 객체를 가리키기 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티 참조할때

→ 이때 변수의 값이 객체가 아니라 null 또는 undefined라면 프로퍼티 참조시 타입에러 발생하고 프로그램 강제 종료된다.

→ 단축평가를 사용하면 에러 발생 막을 수 있다.

[politician-footprints.site](http://politician-footprints.site) : fetch에서 validation 대신??

```jsx
## 
```

1. 함수 매개변수에 기본값 설정할때

→ 함수 호출시 인수 전달하지 않으면 매개변수에는 undefined가 할당되는데 매개변수의 기본값을 설정하면 이로 인한 에러를 방지할 수 있다.

```jsx
function getStringLength(str){
	str = str || '';
	return str.length;
}
```

## 옵셔널 체이닝

optional chaining

`?.` 

좌항의 피연산자가 null 또는 undefined 인 경우 undefined 반환하고, 그렇지 않으면 우항의 프로퍼티를 참조한다. 

단축평가 `&&` 를 활용해 변수가 null 또는 undefined 인지 확인했다가 ES11(2020)부터 도입된 옵셔널 체이닝을 사용할 수 있다.

→ 참조를 계속 이어갈 수 있느냐 또는 피연산자를 그대로 반환하느냐의 차이

## null 병합 연산자

null coalescing

`??`

좌항의 피연산자가 null 또는 undefined 인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

변수에 기본값을 설정할 때 유용하다.


## 10장. 객체 리터럴
### 객체
JS는 객체 기반 프로그래밍 언어다. 원시값을 제외한 나머지는 모두 객체다. 


객체는 0개 이상의 프로퍼티로 구성된 집합이고 프로퍼티는 키와 값으루 구성된다


JS에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 

자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 함수도 프로퍼티 값으로 사용할 수 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드method라 부른다.

(따라서 함수는 객체로부터 독립적이며 메서드는 객체에 종속적이다라고 할 수 있다)


- 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 객체지향 프로그래밍이라 한다.
- 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수 함수라 한다. 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로 그래밍이라 한다.

JS는 프로토타입 기반 객체지향 언어로 클래스 기반 객체지향 언어(C++, java)와 달리 다양한 객체 생성 방법을 지원한다. 

1. 객체 리터럴
    
    ```jsx
    let owl = {
    	director : '안태진',
    	main1 : '유해진',
    	main2 : '류준열',
    	sub1 : '조성하'
    	shoot: function(){
    		console.log('대박나자 ㅋㅎㅎㅎ');
    	}
    }; ##코드 블록의 닫는 중괄호 뒤에는 세미 콜론을 붙이지 않는다. 하지만 객체 리터럴은 값으로 평가되는 표현식이다. 따라서 객체 리터럴의 닫는 중괄 호 뒤에는 세미콜론을 붙인다.
    ```
    
    이렇게 객체 리터럴을 사용하면 클래스 정의하고 new 연산자와 생성자 호출할 필요가 없어진다. 
    
2. Object 생성자 함수
3. 생성자함수
4. Object.create 메서드
5. 클래스

### 프로퍼티

- 일반적으로 프로퍼티 키는 문자열을 사용한다. 식별자 네이밍 규칙을 준수하는 이름인 경우는 따옴표를 생략할 수 있다. (식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표 사용해야한다)
- 프로퍼티 키로 숫자 리터럴 사용하면 따옴표는 붙지 않지만 암묵적 타입 변환 통해 문자열로 변환된다.
- 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 이때 에러가 발생하지 않는다는 점에 주의하자.

### 프로퍼티 접근

프로퍼티에 접근하는 방법은 다음과 같이 두 가지다. 

■ 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법dot notation 

■ 대괄호 프로퍼티 접근 연산자([...])를 사용하는 대괄호 표기법bracket notation

대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표 로 감싼 문자열이어야한다.

```jsx
var person = {
	name : 'Lee'
};

console.log(person.name);
console.log(person['name']);
console.log(person[name]); // ReferenceError: name is not defined
```

→ 대괄호 접근시 따옴표는 프로퍼티 키를 표현식을 이용해 동적으로 생성하는 방법과 구분하기 위해서 인 것으로 보임

```jsx
var obj = {}; 
var key  = 'hello'; 

// ES5: 프로퍼티 키 동적 생성 
**obj[key]** = 'world'; 

// ES6: 계산된 프로퍼티 이름 
// var obj = { [key]: 'world' }; 

console.log(obj); // {hello: "world"}
```

객체에 존재하지 않는 프로퍼티에 접근하면? undefined를 반환한다.

그럼 다음은 어떻게 해석될까?

```jsx
var person = {
'last-name':'Lee',
1:10
};
person.last-name //브라우저 환경과 node.js 환경의 해석이 다름!
```

nodejs에서는person.last를 평가해 undefined로 두고 name이라는 식별자를 찾는다. node.js 환경에서 name이라는 식별자 선언이 없었으므로 `ReferenceError: name is not defined` 에러가 발생한다.

한편 브라우저 환경에서는 전역객체 window의 이름을 가리키는 전역 변수가 name이고 기본값은 빈문자열이다. 따라서 브라우저환경에서는 undefined - ‘ ‘이 되므로 `NaN` 이 반환된다. 

### 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 값이 갱신된다.

### 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 동적으로 생성되어 추가된다.

### 프로퍼티 삭제

`delete` 연산자 사용

### es6에서 추가된 객체 리터럴의 확장

- 프로퍼티 축약
    - 프로퍼티 값으로 먼저 선언된 값이 할당된 변수를 사용할 수 있다.
    - 프로퍼티 키와 변수 이름이 동일하면 프로퍼티키를 생략할 수 있다.
- 프로퍼티 키 동적 생성
    - 계산된 프로퍼티 이름 computed property name
    - 대괄호를 이용해 프로퍼티 키 이름을 표현식으로 나타낼 수 있다
    
    ```jsx
    var prefix 
    var i = 0; 
    var obj = {}; 
    
    // 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성 
    obj[prefix + '-' + ++i] = i; 
    obj[prefix + '-' + ++i] = i; 
    obj[prefix + '-' + ++i] = i; 
    
    console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
    ```
    
    
    
- 매서드 축약 표현
    - 매서드 정의시 function 키워드 생략할 수 있다. 즉 프로퍼티 값에 해당하는 함수만 적어도 된다
    - 단, 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다

<br>

