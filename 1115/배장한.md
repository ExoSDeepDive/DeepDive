### 11장

| 원시 값 | 참조 값 |
| --- | --- |
| 원시 값이 저장된 메모리 공간에는 원시 값 자체가 저장됨 | 참조하고자 하는 값의 메모리 주소가 저장됨. |
| 문자열 | 객체 |


## 원시값

# 불변성이 필요한 이유

- 원시 값을 변경할 수 있다면 예기치 않게 변수 값이 변경될 수 있다는 뜻.
  예상하지 않는 변화가 발생한다는 것은 변수의 상태 변화를 추적하기 어렵게 만듦.
  따라서 의도적으로 재할당을 해야만 값이 변경될 수 있도록 하기 위해 원시 값의 불변성이 중요.

# 대표적 사례: 문자열

- 문자열의 원시 값은 래퍼 객체에 둘러 쌓여 있어서 유사 배열 객체이면서 이터러블이다. 따라서 배열처럼 문자열에 접근할 수 있음. 하지만 원시 값의 불변성 때문에, 기존 문자열의 일부를 수정할 수 없음. 
- 문자열 값을 변경하기 위해선 새로운 문자열 값을 메모리에 저장하여 재할당 하는 방법 밖에 없음.

# 값에 의한 전달

- 정의: 변수에 원시 값을 갖는 변수를 할당하는 경우 원시 값이 복사되어 전달되는 것.
- 엄격한 개념: 어차피 변수는 값을 기억하는 것이 아니라 값이 저장된 메모리 주소를 기억하기 때문에, 변수에 변수를 할당한다는 것은 할당된 변수가 가진 메모리 주소를 전달하는 것이다. 하지만 위의 정의가 통용될 수 있는 것은 아래에서 서술할 자바스크립트의 동작 원리 때문이다.

- (MDN)자바스크립트의 동작: 복사되는 순간 같은 값을 가진 새로운 메모리 공간이 형성되고 해당 주소에 변수가 할당된다.
- 파이썬의 동작: 메모리 주소가 복사되어 그대로 전달됨. 특정 변수에 새로운 값이 재할당되지 않는 이상 두 변수는 같은 값, 같은 메모리 주소를 갖게 됨.

|  | MDN | 파이썬 |
| --- | --- | --- |
| 메모리 주소의 구분 | 변수 할당 시점 | 값 재할당 시점 |

결론: 결국 두 변수의 원시 값은 서로 다른 메모리 공간 주소를 가져, 한쪽에서의 재할당이 이루어져도 서로 간의 간섭이 발생하지 않음.

## 참조 값

# 대표적 사례 - 객체

| 객체지향 | 자바스크립트 |
| --- | --- |
| 클래스의 인스턴스로서 객체가 생성됨 | 클래스 없이 객체 생성 |
| 객체 이전에 프로퍼티, 메서드가 정해져 있음. | 동적으로 프로퍼티와 메서드를 추가할 수 있음. |
|  | 객체 생성과 프로퍼티 접근에 고비용, 편한 사용성 |
|  | 히든 클래스? |

- 객체가 참조 값을 할당받게 되면서 객체는 원시 값과 달리 동적으로 값을 변경할 수 있게됨. 객체가 변경되면 참조 값(메모리 주소)에 위치한 값이 변경되는 것 뿐 변수에 할당된 참조 값은 변하지 않는다.
- 그럼 참조 값이 가리키는 메모리 주소는 왜 원시 값을 가지는 것이 아닌가? 이는 객체가 변경될 때마다 원시 값을 새로운 메모리 공간에 복사하는 과정이 복잡하고 비용이 많이 들기 때문. 즉 메모리를 효율적으로 사용하기 위해. 


# 참조 값에 의한 전달(공유에 의한 전달)

- 변수에 할당된 참조 값이 그대로 전달되는 것으로 여러 개의 식별자가 하나의 객체를 공유할 수 있게 됨. 
- 동작은 ‘값에 의한 전달’과 동일하지만, 전달되는 값이 원시 값이 아니라는 점에서 위의 문제가 발생함. 
- 동작이 같기 때문에 자바스크립트에서는 ‘값에 의한 전달’이라는 개념만 존재한다. 굳이 구분하자면 ‘값에 의한 전달’ 과정에서 전달된 값이 참조 값인 경우를 ‘참조 값에 의한 전달’로 구분한 것. 다른 언어에서의 ‘참조에 의한 전달’과는 다른 개념.

# 얕은 복사와 깊은 복사 

- 얕은 복사: 참조 값을 복사하는 것
- 깊은 복사: 원시 값을 복사하는 것


### 12장 - 함수

## 함수 리터럴

- 인간이 식별할 수 있는 언어로 함수 객체를 생성하는 것

# 리터럴의 구성 요소

- 함수 이름: 함수 몸체에서만 사용될 수 있는 이름으로 함수 외부에서는 변수에 저장하여 변수 식별자로 호출해야한다.
- 함수가 저장된 식별자 뿐만아니라 함수 이름으로도 재귀 함수는 구현할 수 있다.
- 함수 몸체: 함수 호출 시 실행될 문들을 하나의 단위로 저장한 코드 블록
- parameter: 함수 내부로 argument를 전달 받는 변수로 함수 몸채에서 변수로 인식됨.
- argument: 호출한 함수의 내부로 입력할 값들로 ‘arguments’ 객체에 담긴 후 함수 내부에서 사용된다.
- 자바스크립트의 함수는 parameter와 argument 개수의 일치 여부를 따지지 않는다. 따라서 ‘arguments’ 객체는 parameter의 갯수가 변할 수 있는 함수를 사용하는데 유용하다.

## 함수 정의 방법

# 함수 선언문

- 함수의 이름, 매개변수, 함수 식을 선언하는 것

```jsx
function add(x, y) {
	return x + y;
}
```

- 표현식이 아닌 문으로서 원래대로라면 변수에 할당될 수 없음. 하지만 자바스크립트 엔진의 맥락적 코드 이해로 표현식으로서 이해되면서 변수에 할당될 수 있음. 하지만 함수의 이름은 함수 내부에서만 사용되며, 해당 함수를 호출하기 위해서는 함수를 가리키는 식별자로 호출해야 함. 

# 함수 리터럴 표현식

```jsx
// 함수 이름은 생략 가능!
const add = function add(x, y) {
	return x + y;
}
```

## 함수 호이스팅

| 함수 선언문 | 함수  표현식 |
| --- | --- |
| 선언된 함수가 호이스팅 됨 | 선언된 변수가 호이스팅 됨 |
| 선언 이전부터 함수를 참조할 수 있음. | 표현시 이전에 함수를 참조하면 undefined |

## 함수의 종류

# 순수 함수

- 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수
- 함수형 프로그래밍 패러다임의 근본 개념

# 재귀 함수: 자기 자신을 호출하는 함수

# 중첩 함수: 함수 내부에 정의된 함수로 자신의 외부 함수 내부에서만 호출될 수 있다.

# 콜백 함수: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

# 고차 함수: 매개변수를 통하 함수의 회부에서 콜백 함수를 전달받은 함수
