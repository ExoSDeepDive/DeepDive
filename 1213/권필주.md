🔐 개념 숙지

> - this 개념 한 줄로
> - 함수 호출 방식별 this 바인딩
> - 실행컨텍스트 cf. 렉시컬 환경


💡생각해보기

> ## Quiz 1.
> 다음의 this가 가리키는 것은?
```jsx
function Circle(radius){
	this.radius = radius;
	this.getDiameter = function () {
		return 2 * this.radius;
	};
    console.log('this: ', this);
}


const circle = Circle(15);  
        
console.log(circle)  //? 
                      // this: ?
```
> ## Quiz 2.
> 실행컨텍스트와 렉시컬 환경의 관계를 설명해보세요.

## 22장. this

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키기 위한 특수한 식별자.

자기 참조 변수 self-referencing variable

### **this 바인딩**

this가 가리키는 값은 함수 호출 시점에 함수의 종류에 따라 동적으로 결정됨
- 일반 함수 호출 ⇒ this는 전역 객체 가리킴
- 화살표 함수 호출 ⇒ this는
- 객체의 매서드 내부 ⇒ 매서드를 호출한 객체
- 생성자 함수 내부 ⇒ 생성자함수가 생성할 인스턴스
- Function.prototype.apply/call/bind()⇒ 인수에 의해 결정됨

cf. 렉시컬 스코프

    함수 정의가 평가되어 함수 객체가 생성되는 시점에 결정

**매서드 호출**

매서드를 **호출( *not 매서드 소유*)**한 객체, 즉 매서드 이름앞의 dot 연산자앞에 기술한 객체가 this 에 바인딩

만약 다른 객체의 프로퍼티에 할당하고 그 다른 객체에서 호출하면 처음에 정의된 객체가 아니라 바뀐 객체를 가리킨다. 

이를 일반함수로 호출한다면 전역 객체를 가리키게 된다. 

prototype 프로퍼티의 매서드로 사용된 this도 호출 객체에 바인딩된다

**생성자 함수 호출**

생성자 함수가 생성할 인스턴스

만약 new 연산자와 호출하지 않고 일반함수로 호출하면 this는 전역 객체를 가리킨다.

**Function.prototype.apply/call/bind()**

.apply()와 .call()은 모두 첫번째 인수로 전달한 특정 객체를 this에 바인딩하고 인수리스트가 있다면 이를 전달하고 함수를 호출한다.
둘은 보통 arguments 객체와 같은 유사배열 객체에 배열 매서드를 사용하는 경우 이용한다. 

.bind()는 매서드의 this와 그 내부의 중첩함수 또는 콜백 함수의 this가 불일치하는 문제 해결에 이용한다.

주의할 점은 bind()는 인수로 전달한 특정 객체를 this 바인딩하고 이 함수를 생성해 반환할 뿐 함수를 호출하진 않는다. 따라서 bind로 this를 바인딩한 함수는 명시적으로 호출해야한다.


## 23장. 실행컨텍스트
**ECMAScript의 소스코드의 타입 4가지**

- 전역 코드
- 함수 코드
- eval 코드
- 모듈 코드

⇒ 소스코드를 평가하게 되면 각 타입에 맞는 스코프의 컨텍스트가 생성되고 이후 실행 과정이 진행된다

### 소스코드 평가와 실행

실행에 앞서 평가 과정을 거치면 코드 실행 준비를 한다

- 평가 과정
    - 실행 컨텍스트 생성
    - 변수, 함수 등의 선언문만 먼저 실행해 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록
- 실행 과정
    - 런타임 시작
    - 평가과정에서 실행된 선언문 제외하고 할당문 같은 코드를 순차적으로 실행
    - 만약 할당문 실행에서 할당하려는 변수가 선언된 변수인지 확인하는 곳이 실행컨텍스트가 관리하는 스코프.
    - 스코프에 등록되어 있으면 값을 할당하고 결과를 실행컨텍스트에 등록

### 실행 컨텍스트의 역할

코드가 실행되기 위해 스코프, 식별자, 코드 실행 순서 등을 관리하는 것이 실행 컨텍스트

1. 선언에 의해 생성된 모든 식별자를 스코프를 구분해 등록, 상태 변화 관리
2. 중첩 관계에 따라 스코프 체인 형성. 스코프 체인을 통해 상위 스코프로 이동하여 식별자 검색
3. 현지 실행 중인 코드의 실행 순서 변경(ex 함수호출에 의한 실행 순서 변경)

식별자와 스코프는 **렉시컬 환경**으로 관리하고

코드 실행 순서는 **실행컨텍스트 스택**으로 관리함

### **실행컨텍스트 스택**

JS 엔진은 전역 코드를 먼저 평가해 **전역 실행 컨텍스트** 생성하고 함수가 호출되면 함수 코드 평가해 **함수 실행 컨텍스트** 생성함

이렇게 생성된 실행 컨텍스트들은 스택 구조로 관리되는데 이를 **실행 컨텍스트 스택**이라 함

### 렉시컬환경

Lexical Environment
⇒ 렉시컬 환경의 역할은 식별자와 스코프 관리

구성요소 2개

- 환경레코드 → 식별자 등록 및 관리
- 외부렉시컬환경에 대한 참조 → 스코프체인 구현 및 관리

### 실행컨텍스트의 생성과 식별자 검색 과정

1. 전역 코드 평가
    - 전역 객체 생성
    - 전역 코드 평가
        - 전역 실행 컨텍스트 생성
        - 전역 렉시컬 환경 생성
            - 전역 환경 레코드 생성
            - this 바인딩
            - 외부 렉시컬 환경에 대한 참조 결정

2. 전역 코드 실행
    - 식별자 결정
    - 변수 할당문, 함수 호출문 실행

3.  함수 코드 평가
    - 함수 실행 컨텍스트 생성
    - 함수 렉시컬 환경 생성
        - 함수 환경 레코드 생성
        - this 바인딩
        - 외부 렉시컬 환경에 대한 참조 결정

4. 함수 코드 실행
        - 전역 함수 코드 평가 및 실행
        - 내부 함수 코드 평가 및 실행
        - 내부 함수 코드 실행 종료
        - 전역 함수 코드 실행 종료

5. 전역 코드 실행 종료


## 24장. 클로저
함수를 일급 객체로 취급하는 함수형 프로그래밍 언어(예: 하스켈Haskell, 리스프Lisp, 얼랭Erlnag, 스칼라Scala 등)에서 사용되는 중요한 특성이다.

JS 고유의 개념이 아니다. 따라서 ECMAScript사양에는 등장하지 않고 MDN의 정의는 다음과 같다.

> A **closure**  is the combination of a function bundled together (enclosed) with references to its surrounding state (the **lexical environment** ). In other words, a closure gives you access to an outer function's scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.
> 

> **클로저**는 함수와 함수가 선언된 렉시컬 환경의 조합이다. 클로저를 이해하려면 자바스크립트가 어떻게 변수의 유효범위를 지정하는지(Lexical scoping)를 먼저 이해해야 한다.
> 

“A closure is the combination of a function and the lexical environment within which that function was declared.” 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.
