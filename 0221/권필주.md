🔐 개념 숙지
> - 동기/비동기, 블로킹/논블로킹
> - JS 엔진, 브라우저 엔진, 이벤트 루프
> - 



💡생각해보기
> ## Quiz 1.
다음 코드 동작을 실행 컨텍스트, 이벤트 루프, 콜스택으로 설명해보세요.
```
function foo(){
	console.log('foo')
}

function bar(){
	console.log('bar')
}

setTimeout(foo, 0);

bar();
```

> ## Quiz 2. 
다음 중 크롬 브라우저의 Web API가 아닌 것은?
- DOM
- Fetch API
- History API
- IndexedDB
- File System
- XMLHttpRequest
- Websocket API

## 40장. EVENT

Window, Document, HTMLElement 타입의 객체는 onclick과 같은 특정 이벤트에 대응하는 다양한 이벤트 핸들러 프로퍼티를 가지고 있다. 
이벤트 중심으로 프로그램을 제어하는 방식을 이벤트 드리븐 프로그래밍이라고 한다.
이벤트 타입은 약 200가지가 있고 이는 MDN의 event reference에 명세되어 있다
이벤트 핸들러 등록 방법 3가지
어트리뷰트 방식
함수 참조가 아니라 함수 호출문 할당하는 점 주의
이벤트핸들러에 인수 전달하기 위해. 참조문이면 인수 전달할 방법이 없음!
<Button onclick="sayHi('PJ')">Click me</Button>
<script>
	function sayHi(name){
		console.log(`Hi, ${name}`);
	}
</script>
프로퍼티 방식
이벤트 발생시킬 이벤트 타겟 지정하면 된다
Window, Document, HTMLElement 타입의 DOM 노드 객체는 이벤트에 대응하는 다양한 이벤트 핸들러 프로퍼티를 가지고 있다. 
어트리뷰트 방식처럼 HTML과 JS가 뒤섞이는 문제 해결할 수 있지만
프로퍼티 하나에 하나의 이벤트 핸들러만 등록할 수 있다
<script>
	const $button = document.querySelector('button');
	$button.onclick = function(){
		console.log(`Hi, ${name}`);
	}
</script>

addEventListener 매서드 방식
이벤트 타겟에 매서드 사용하여 핸들러 등록
이벤트 핸들러 제거
EventTarget.removeEventListener()
이벤트 핸들러가 기명이 아니라면 제거하기 힘들다
이벤트 객체
이벤트가 발생하면 이벤트 정보를 담고 있는 이벤트 객체가 동적으로 생성된다. 생성된 이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달된다. 
이벤트 전파
DOM트리 상의 요소 노드에서 발생한 이벤트는 DOM트리를 통해 전파됨. 
캡처링 단계 event capturing phase  이벤트가 상위 요소에서 하위 요소 방향으로 전파
버블링 단계 event bubbling phase  이벤트 하위 요소에서 상위 요소 방향으로 전파
타겟 단계 target phase 이벤트가 이벤트 타겟에 도달
이벤트 핸들러 등록 방식 중 어트리뷰트, 프로퍼티 방식은 타겟 단계와 버블링 단계의 이벤트만 캐치할 수 있다.
addEventListener 방식의 이벤트 핸들러는 타겟 단계, 버블링 단계, 캡처링 단계의 이벤트도 선별적으로 캐치할 수 있다. 캡처링 단계 이벤트 캐치하기 위해선 이벤트 리스너의 3번째 인수로 true 전달해야함
이벤트가 버블링으로 전파되는지 여부를 나타내는 이벤트 객체의 공통 프로퍼티는 event.bubbles 이다. (true/ false)
이벤트 객체의 전파 방지는 stopPropagation 매서드를 통해서이다. 하위 DOM요소의 이벤트를 개별적으로 처리하기 위해 이벤트 전파 중단시키는 것.
이벤트 위임
여러 개의 하위 DOM요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM요소에 이벤트 핸들러를 등록하는 방법
상위 DOM 에서 모든 하위 요소의 동일한 이벤트에는 반응하게 되므로 기대한 DOM요소에 한정하도록 이벤트 타겟을 검사해야함 → Element.prototype.matches() 인수로 전달된 선택자에 의해 특정 노드 탐색 가능한지 확인. 만약 기대하는 dom 요소가 아니라면 return 시켜 핸들러를 종료시킬 수 있다. 
DOM요소의 기본 동작 중단
이벤트 객체의 preventDefault 매서드는 DOM요소의 기본 동작을 중단시킨다. 
즉 반대로 보면 모든 DOM 요소는 저마다의 기본 동작이 있는데 이를 제어해야할 때 사용하는 것이다. 
이벤트 핸들러 내부의 this
어트리뷰트 방식 
핸들러 내부의 this는 window객체를 가리킨다. 
이는 어트리뷰트 방식이 값으로 지정한 문자열을 사실상 암묵적으로 생성되는 이벤트 핸들러의 문이기 때문이다. 문자열로 지정한 핸들러 이름은 사실 일반 함수 이름이 되고 일반함수로 호출되는 함수 내부의 this는 전역 객체이다.
⚠️ p.789 예제 40-38의 이벤트 핸들러 인수르 넘긴 this가 이벤트 바인딩한 DOM요소, 즉 예제에선 button 가리키지만 핸들러 내부에서 this를 호출하면 이는 전역 객체window를 가리킨다. 
프로퍼티 방식
이벤트 바인딩한 DOM요소 가리킴
즉 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같음
addEventListener 방식
이벤트 바인딩한 DOM요소 가리킴
즉 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같음
화살표함수로 정의한 이벤트 핸들러 내부의 this는 상위 스코프의 this와 같음.
화살표 함수는 자체의 this 바인딩을 가지지 않음.
클래스에 이벤트 핸들러를 바인딩한 this는 매서드 내부의 this가 클래스가 생성할 인스턴스를 가리키지 않는다. 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM요소를 가리킨다. 
→ bind()매서드 이용하면 클래스의 매서드 내부의 this가 클래스가 생성할 인스턴스를 가리키도록 할 수 있다. [예제 40-42]
→ 또는 클래스 필드에서 화살표함수로 선언한 매서드를 이벤트 핸들러로 등록해도 된다. 
커스텀 이벤트
이벤트는 발생하면 암묵적으로 이벤트 객체가 생성되어 종류에 따라 이벤트 타입이 결정된다. 
이벤트 생성자함수 CustomEvent() 를 사용해 만든다.
커스텀 이벤트 객체는 버블링 되지 않으며 preventDefault로 취소할 수 없다
bubbles, cancelable 프로퍼티의 값이 false 기본 설정이다
CustomEvent()함수의 두 번째 인수로 위 두 프로퍼티를 갖는 객체를 전달해 true로 설정 할 수 있다. 
커스텀 이벤트의 isTrusted 프로퍼티의 값은 항상 false
커스텀 이벤트는 dispatchEvent 매서드로 이벤트를 발생시킬 수 있다. 
일반적인 이벤트 핸들러는 비동기 방식으로 동작한다.


커스텀 이벤트는 동기 방식으로 동작한다. 
커스텀 이벤트는 반드시 addEventListener 매서드 방식으로 등록해야한다


## 41장. 타이머
### 디바운스

짧은 시간 간격으로 연속 발생하는 이벤트에 대해 핸들러를 호출하지 않다가 일정 시간 경과 후 이벤트 핸들러가 한번만 호출되도록. 이벤트를 그룹화해 마지막 한번만 이벤트 핸들러가 호출되도록하는 기법

### 스로틀 Throttle

짧은 시간 간격으로 연속 발생하는 이벤트에 대해 일정 시간 간격으로 핸들러를 한 번 호출하도록 하는 것. 호출 주기를 만드는 것.

스크롤 이벤트나 무한 스크롤 ui 구현에 유용

lodash의 throttle 함수 사용 권장

## 42장. 비동기 프로그래밍
### 동기 / 비동기

동기 synchronous 처리

- 현재 실행중인 태스크가 종료할 때까지 다음 실행 태스크가 대기 하는 방식
- 호출하는 함수가 호출되는 함수의 완료 신호를 받고 다음 작업을 이어감
- 태스크를 순서대로 하나씩 처리하므로 실행 순서가 보장된다는 장점
- 호출되는 함수의 실행이 종료할때까지는 이후 태스크들이 블로킹되는 단점

비동기 asynchronous 처리

- 현재 실행중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식
- 블로킹 발생하지 않는다는 장점
- 실행 순서 보장되지 않는 단점
- 이벤트 루프, 태스크 큐와 깊은 관계

### 이벤트 루프와 태스크 큐

둘은 모두 JS엔진은 아니다.

브라우저가 제공하는 내장 기능이다.

**콜스택**

실행컨텍스트 스택과 같다

소스코드(젼역 코드, 함수 코드) 평가 과정에서 실행 컨텍스트가 추가 또는 제거 되는 스택 자료 구조가 실행컨텍스트 스택이다.

JS엔진에는 하나의 콜 스택만 있고 최상의 실행 컨텍스트가 종료되고 콜스택에서 제거 되기 전까지는 다른 태스크는 실행되지 않는다

**태스크큐**

브라우저 환경. ( JS엔진 X)

함수나 이벤트 핸들러가 일시적으로 보관되는 영역

**마이크로태스크큐**

프로미스 처리

우선순위 더 높음

45.7절 마이크로태스크 큐

**이벤트 루프**

브라우저 환경. ( JS엔진 X)

호출 스케줄링이나 함수 등록은 브라우저나 Node.js가 담당한다.

브라우저에서 콜스택에 실행중인 실행 컨텍스트가 있는지, 대기 중인 함수가 태스크 큐에 있는지 확인하고 콜스택이 비어있고 태스크 큐에 대기 중 함수가 있으면 순차적으로 콜스택으로 이동시키는 역할을 한다.