# 배퀴즈온더블럭
1. prototype의 개념을 한 줄로 설명하세요.
2. 객체 리터럴을 이용하여 객체를 생성하는 것과 Object 생성자 함수로 객체를 생성하는 것의 공통점과 차이점을 설명하세요.
3. 정적 프로퍼티(메서드)의 개념을 설명하세요.


# 19장 - prototype

### 객체지향 프로그래밍

1. 추상화: 프로그램에 필요한 속성만 간추려 표현하는 것
2. 객체: 상태 데이터(프로퍼티)와 동작(메서드)을 하나의 논리적인 단위로 묶은 복합적인 자료 구조
3. 상속
    1. 불필요한 중복을 제거함으로서 코드의 재사용성을 늘림.
    2. 여러 객체에 공통으로 들어가는 프로퍼티, 메서드를 부모 객체에서 상속해주는 방향으로 구현
    

### prototype

1. __proto__ 접근자 프로퍼티
    1. 프로토타입 객체: 부모 객체의 역할을 하여 자식 객체가 부모의 프로퍼티를 자유롭게 사용할 수 있도록 함.
    2. 접근 방법 
        1. 내부 슬롯인 [[Prototype]]은 __proto__라는 접근자를 통해 간접적으로 접근하게 됨.
        2. __proto__를 활용하는 이유는, 순환 상속을 막기 위해 단방향 연결리스트 자료구조의 형태를 가지도록 하고자 하기 이함.
        3. 그냥 호출하면 get, 변수를 할당하면set 처럼 동작한다.
        4. 모든 객체는 Object.prototype이라는 객체를 상속받는다. 
            1. 일반적으로 객체가 리터럴로 형성된다고 생각했을 때의 이야기. 
                1. 객체 리터럴에 의해 생성된 객체는 Object.prototype을 프로토타입(__proto__으로 접근)으로 갖는 반면, 
                2. 생성자 함수에 의해 생성된 객체는 생성자 함수.prototype을 프로토타입(__proto__)으로 갖는다.
            2. 프로토타입 체인의 최상위 객체에 해당한다.
        5. 객체를 직접 상속하는 경우엔 __proto__를 상속받지 않는다.
            1. 이 때 prototype에 접근하기 위해 `Object.getPrototypeOf`, `Object.setPrototypeOf`을 사용하자.
    
2. prototype 프로퍼티 (생성자 함수에 의한 객체 상속) 
    1. 생성자 함수는 본인이 생성하는 인스턴스들의 프로토타입을 가리키는 **prototype 프로퍼티**를 갖는다. 
    2. 생성자함수.prototype 또한 [[Prototype]]으로 Object.prototype을 가진다.
    3. 생성자 함수가 아닌 함수는 prototype 프로퍼티를 소유하지 않는다.
    4. 생성자 함수에 의해 생성된 객체의 __proto__는 **생성자 함수가 생성한 인스턴스**를 가리킨다.
    5. prototype 프로퍼티는 객체를 값으로 가지며, 해당 객체는 constructor라는 프로퍼티를 가진다. constructor는 자신을 참조하고 있는 생성자 함수를 가리킨다.
    6. prototype의 constructor를 통해 생성자 함수와 그로 인해 생성된 객체가 연결되는 것이다.
    
3. 객체 리터럴에 의한 객체 상속
    1. Object 생성 함수와의 비교
        1. 공통점: 추상 연산 OrdinaryObjectCreate를 호출한다는 점
            1. OridnaryObjectCreate
                1. 생성할 객체의 prototype을 인수로, 추가할 프로퍼티 목록을 옵션으로 전달
                2. 생성된 객체의 [[Property]] 내부 슬롯에 prototype을 할당한 후 객체를 리턴한다.
        2. 차이점: new.target(생성자 함수 확인 절차), 프로퍼티 추가 처리 과정이 닫름
    2. **가상의 생성자 함수**
        1. 상속을 위해 프로토타입이 필요하기 때문.
        2. 프로토타입 객체만 있으면 되는 것이 아님. 해당 객체를 extends 형태로 넘기는 건 객체지향의 방식. 자바스크립트에서 프로토타입 객체는 생성자 함수(constructor)에 달려 있음.
        3. 결론: 객체 리터럴에 의한 객체 생성 또한 생성자 함수를 거치는 것.
        
4. prototype 객체의 생성 시점
    1. 생성자 함수로 평가되어 함수 객체를 생성하는 시점에 프로토타입이 생성됨.
    2. 함수 선언문으로 정의되는 경우 함수 호이스팅에 의해 어떤 코드보다 먼저 평가되어 함수 객체로 생성되며 더불어 프로토타입도 생성됨.
    
5. 프로토타입 체인
    1. 객체 생성 방식에 따른 생성 과정
        
        |  | 객체 리터럴, new Object() | 생성자 함수 |
        | --- | --- | --- |
        | prototype | Object.prototype | 본인.prototype |
        | 프로퍼티 | constructor를 포함하여 Object에 달려잇는 다양한 것들 | only constructor |

    2. 생성자 함수로 생성된 객체가 Object 메소드를 쓸 수 있는 이유
        1. 프로토타입 체인을 타고가기 때문
            1. 생성된 객체의 [[Prototype]] 접근
            2. 생성자함수.prototype의 [[Prototype]] 접근
            3. Object.prototype 도달

    3. 오버라이딩, 프로퍼티 섀도잉
        1. instance의 property가 prototype의 property와 동일한 이름을 가질 때, prototype의 그것을 덮어쓰고 가려지는 것
        2. 인스턴스 단에서 프로퍼티 삭제 후 해당 프로퍼티를 다시 호출하면 prototype의 프로퍼티가 호출된다.

    4. 프로토타입의 교체
        1. 생성자 함수.prototype 
            1. 새로운 객체를 할당하는 방식으로 프로토타입을 교체할 수 있음.
            2. 복구: 새로운 객체의 constructor 프로퍼티에 생성자 함수를 할당하면 다시 연결이 이어짐.
        2. 인스턴스의 __proto__
            1. 이미 생성된 객체의 프로토타입을 교체한다는 점에서 위의 방식과 다름.

    5. instanceof
        1. prototype chain을 검토하기 때문에, 중간에 프로토타입의 교체가 이루어지면 instanceof으로 교체된 객체를 연산하면 false가 나올 것.
        
6. 직접 상속
    1. Object.create(생성할 객체의 prototype, 생성될 객체의 프로퍼티 옵션)
    2. 객체 리터럴 내부에 __proto__ 프로퍼티에 할당하는 방식
    
7. 정적 프로퍼티/메서드
    1. 생성자 함수가 생성한 인스턴스에 상속하지 않고, 본인만이 갖고 있는 프로퍼티, 메서드
    2. prototype의 프로퍼티, 메서드는 instance를 만들어야만 호출할 수 있음

# 20장 - strict mode

1. 배경
    1. 암묵적 전역: 지역 스코프에서 호출된 변수가, 전역 스코프까지에서도 선언되지 않았음에도 자바스크립트가 동적으로 전역 객체에 프로퍼티로서 해당 변수를 생성하는 경우.
    2. 이를 막기위해선 반드시 let, const를 활용해야 함. 하지만 오타의 가능성도 있음
    3. 따라서 근본적으로 이를 막을 수 있는 해결책으로 등장
    
2. 적용 방법
    1. eslint
    2. 적용하려는 스코프의 선두에 `‘use strict’`
    3. 하지만 전역, 함수 단위로 사용하는 것은 서드파티 라이브러리와의 충돌 가능성, 함수 외부의 컨텍스트와의 충돌 가능성을 생각했을 때 바람직하지 않음.
    4. 즉시 실행 함수로 감싼 스크립트 단위에서 사용하는 것이 적절할 것.
    
3. 효과
    1. 일반 함수의 this: 생성자 함수가 아닌 이상 this를 쓸 일이 없기 때문에 undefined로 초기화됨
    2. arguments 객체: 매개변수에 전달된 인수를 변경하는 경우 반영되지 않음.

# 21장 - 빌트인 객체

### 래퍼 객체

1. 존재 이유: 원시값이 객체처럼 프로퍼티, 메서드를 가진 채 동작할 수 있도록 하기 위함

2. 구성: 빌트인객체.prototype을 상속 받은 래퍼 객체는 값이 담긴 [[OOData]] 내부 슬롯을 가짐(ex. [[StringData]]

3. 작동 원리: 상속받은 프로퍼티, 메서드를 이용할 때 식별자는 생성된 인스턴스를 임시로 가지며, 프로퍼티 메서드 호출이 끝나면 다시 원시값을 가진다. 이에 직전 호출에 쓰인 인스턴스는 가비지 컬렉션의 대상이 된다.

### 전역 객체

1. 특징
    1. 전역 객체를 생성하는 생성자 함수가 없다.
    2. window or global을 생략할 수 있다.
    
2. 프로퍼티 구성
    1. 표준 빌트인 객체
    2. 환경에 따른 호스트 객체(클라이언트 web api 또는 node.js의 api)
    3. 전역 프로퍼티
        1. Infinity: 상수 숫자값
        2. NaN: typeof NaN === number
        3. undefined: typeof undefined === undefined
    4. 전역 함수
        1. eval
            1. 문자열을 인수로 받아 코드를 실행하는 함수
            2. 기존의 스코프를 런타임에 동적으로 수정
            3. 단, strict mode에서는 자신만의 스코프를 생성함.
            4. let, const 키워드를 사용한 경우에도 strict mode를 적용함.
        2. IsFinite, IsNaN
        3. parseFloat, parseInt
        4. encodeURI, decodeURI
            1. component??
