  >(19장) Q. `__proto__` 프로퍼티를 통해 프로토타입에 접근하는 이유와 그럼에도 코드 내에서 `__proto__` 프로퍼티를 사용하지 않아야 하는 이유는?<br>그렇다면 `get Object.prototype.__proto__`와 `set Object.prototype.__proto__`를 무엇으로 대체해서 사용해야 하는가?<br>

  >(20장) Q. strict mode에서 에러가 발생하는 경우 4가지?

  >(21장) Q. 다음 코드의 실행 결과와 그 과정을 설명하시오.
    ```javascript
    const student = '황채림';
    student.age = 24;
    console.log(student.age);
    console.log(typeof student, student);
    ``` 

<br>

# 19. 프로토타입
- 자바스크립트는 명령형/함수형/프로토타입 기반 객체지향 프로그래밍 언어(원시 타입을 제외한 모든 것이 객체)
- 추상화: 실체를 구분할 수 있는 여러 속성이 있는데 이 중 필요한 속성만 간추리는 것
- 객체: 여러 값들을 속성으로 하나에 묶은 자료구조
- 객체지향 프로그래밍에서의 객체 = 상태(데이터, 프로퍼티) + 동작(상태를 조작, 메서드)<br><br>
- 객체지향 프로그래밍에서는 **상속**으로 다른 객체의 속성을 가져와서 쓸 수 있음 => 코드 재사용으로 중복 제거
- 생성자로 객체를 만들 때마다 내용이 같은 메서드가 계속 생김-> 프로토타입에 메서드 추가해서 해결
  ```javascript
  School.prototype.getTotal = function(){
    return this.students.length;
  } 
  //School 생성자로 만들어진 모든 객체가 메서드를 공유함(상속받음)
  ```
- 모든 객체는 [[Prototype]] 슬롯에 하나의 프로토타입 참조를 가짐(객체 리터럴로 만들면 `Object.prototype`, 생성자로 만들면 생성자의 prototype, 프로토타입이 없으면 `null`)
- 객체->프로토타입 &nbsp;(간접)접근은 `__proto__`(객체가 소유한 프로퍼티는 아니지만 모든 객체는 `Object.prototype` 객체를 상속받기 때문에 사용 가능)<br>
프로토타입->생성자함수 접근은 `contstructor`<br>
생성자함수->프로토타입 접근은 `prototype`
- `__proto__`는 접근자 프로퍼티 -> `__proto__`를 사용하면 getter와 setter를 호출해서 객체의 프로토타입에 접근하거나 바꿈 (프로토타입 체인은 단방향 연결리스트로 구현되어야 하는데 서로 참조하는 순환 참조 프로토타입 체인이 생기면 무한루프에 빠지기 때문에 `__proto__` 프로퍼티를 통해서만 접근할 수 있도록 되어 있음) => 직접 상속으로 프로토타입 없는 객체를 만들면 `__proto__` 프로퍼티가 `undefined`로 뜨기 때문에 `__proto__`보다는 `Object.getPrototypeOf()`(ES5), `Object.setPrototypeOf`(ES6) 사용을 권장
- **생성자 함수**로 생성된 함수 객체는 `prototype` 프로퍼티를 가짐(화살표 함수나 `function` 생략하고 선언한 축약 표현은 안됨) -> `prototype`과 `__proto__`는 같은 프로토타입을 가리킴, 누가 상속받느냐의 차이
- 모든 프로토타입은 `constructor` 프로퍼티를 가지고 [`prototype`으로 자신을 참조하는] 생성자 함수를 가리킴 => 생성자 함수로 객체를 생성하면 생성된 객체가 상속받은 프로토타입(`__proto__`)의 `contructor`가 생성자 함수를 가리키게 됨<br>
=> 생성자 함수&프로토타입은 항상 쌍으로 존재!!<Br>(프로토타입의 constructor는 생성자 함수를 가리키고 생성자 함수의 prototype은 프로토타입을 참조하는 관계)
- 리터럴 표기법(`new` 연산자 없이 생성)으로 객체를 만들면 `OrdinaryObjectCreate`를 호출해서 빈 객체를 생성한 뒤에 `new.target` 확인해서 타겟이 있으면 프로퍼티를 추가하기 때문에 `Object` 생성자 함수가 생성한 객체가 아니게 됨

>그럼 274p.에 `Object` 생성자 함수에 인수가 전달되지 않거나 `undefined`/`null`이 전달되면 `OrdinaryObjectCreate`를 호출해서 빈 객체를 만든다고 돼있는데 이렇게 생긴 객체도 `Object` 생성자 함수가 생성한 객체는 아닌건가?

>276p. 리터럴 표기법에 의해 생성된 객체의 생성자 함수는 `Object`가 아니라고 하지 않았나???

<br><br>

# 20. strict mode
- 암묵적 전역: 스코프 체인을 따라 확인했는데 변수의 선언이 없을 때 자바스크립트 엔진이 ReferenceError를 발생시키지 않고 암묵적으로 전역 객체에 변수를 동적 생성하는 것, 전역 변수처럼 사용하게 됨 -> ES5에 생긴 strict mode에서는 오류의 가능성이 높거나 최적화에 문제가 생길 코드에 에러를 발생시킴
- 선두에 `use strict;`
  - 전역에 적용하면 스크립트 단위로 작동하는데 라이브러리는 non-strict mode라면 오류가 발생할 수 있음
  - 함수 단위로 적용하는 것도 지양

  => 즉시 실행 함수(`function(){}`)로 스크립트 전체를 감싸고 그 내부에 strict mode 적용
- strict mode에서 발생하는 에러
  - 암묵적 전역: 선언하지 않은 변수 참조 -> `ReferenceError`
  - 변수/함수/매개변수 삭제: delete 연산자로 삭제 -> `SyntaxError`
  - 매개변수 이름 중복: `SyntaxError`
  - `with`문 사용: `with`로 전달받은 객체를 스코프 체인에 추가 -> `SyntaxError`
- 일반 함수(생성자 함수가 아닌)를 호출하면 `this`에 `undefined` 바인딩됨
- 매개변수에 전달된 값을 재할당해도 `arguments` 객체에 반영되지 않음

<br><Br>

# 21. 빌트인 객체
- 자바스크립트 객체는 3종류
  1. 표준 빌트인 객체
     - ECMAScript에 정의, 실행 환경에 관계없이 전역으로 사용 가능
     - `Math`, `Reflect`, `JSON`은 생성자 함수가 아닌 표준 빌트인 객체라서 정적 메서드만 제공, 나머지 표준 빌트인 객체는 모두 생성자 함수 객체라서 프로토타입 메서드(Ex. `str.length()`)&정적 메서드(인스턴스 없이도 호출 가능, Ex. `String.raw(str)`) 제공
     - 문자열/숫자/불리언 원시값을 객체처럼 사용하려고 하면 자바스크립트 엔진이 암묵적으로 임시 객체(=래퍼 객체)를 생성해서 사용하고 다시 원시값으로 되돌림 -> 래퍼 객체가 상속받은 프로토타입의 메서드를 사용할 수는 있으나 호출이 끝난 뒤에 래퍼 객체는 가비지 컬렉션의 대상이 되므로 실행한 내용이 저장되지 않고 다시 호출하면 완전히 새로운 래퍼 객체가 생성됨
     (※`null`/`undefined`는 래퍼객체 생성 안됨)<br>
     => 문자열/숫자/불리언은 생성자 함수로 생성할 필요가 없음
  2. 호스트 객체
     - ECMAScript에 정의돼있지는 않지만 실행 환경에서 추가 제공, 브라우저에서는 클라이언트 Web API, Node.js에서는 Node.js만의 API가 해당
  3. 사용자 정의 객체<br><br>
### 전역 객체
- 코드가 실행되기 전에 자바스크립트 엔진이 가장 먼저 생성하는 최상위 객체, 어떤 다른 객체에도 속하지 않음
- 프로토타입 상속 관계에서 최상위라는게 아니라 어떤 객체의 프로퍼티로 속하지도 않으면서 객체의 계층적 구조상 표준 빌트인 객체&호스트 객체를 프로퍼티로 가진다는 의미
- 브라우저에서는 `window`/`self`/`this`/`frames`, Node.js에서는 `global`
  - ES11에서는 다 통일한 `globalThis`가 생김
- 표준 빌트인 객체/호스트 객체/전역 변수(`var`)/암묵적 전역/전역 함수를 프로퍼티로 가짐 <br>(`let`/`const`는 전역 객체의 프로퍼티가 아님)
- 개발자가 생성 불가(생성자 함수가 없음)
- 프로퍼티/메서드 참조할 때 `window`/`global` 생략 가능 => 전역 변수/전역 함수처럼 사용 가능
- 브라우저 환경의 모든 코드는 (`script`로 분리되어 있어도) 하나의 전역 객체 `window`를 공유
- 빌트인 전역 프로퍼티: 전역 객체의 프로퍼티, 앱 전역에서 사용하는 값
  - `Infinity`: number 타입
  - `NaN`: number 타입
  - `undefined`: 원시값
- 빌트인 전역 함수: 전역 객체의 메서드
  - `eval`: 전달받은 문자열을 평가하거나 실행, 모든 문을 실행해서 결과값을 반환
    - 객체/함수 리터럴은 반드시 괄호로 감싸야 함(Ex. `eval('({a:1})')`)
    - 런타임에 자신이 호출된 위치의 스코프를 동적으로 수정함 (※ strict mode에서는 수정 없이 자체적인 스코프 생성)
    - 전달받은 코드가 `let`/`const`를 사용하면 암묵적으로 strict mode 적용<br>

    => 보안에 취약하고 처리 속도가 느리므로 사용 금지
  
  - `isFinite`: 인수가 유한수인지 검사해서 불리언 리턴
    - 숫자가 아닌걸 전달받으면 숫자로 변환 => `null`은 숫자 `0`으로 변환되기 때문에 `true` 리턴
    - 인수가 `NaN`이면 `false` 리턴
  - `isNaN`: 인수가 `NaN`인지 검사해서 불리언 리턴(숫자로 타입 변환)
    - `''`와 `' '`는 숫자 `0`으로 변환돼서 `false` 리턴
  - `parseFloat`: 문자열 인수를 실수로 해석해서 리턴
    - 공백이 포함된 문자열은 첫번째 문자열만 변환(맨 앞과 맨 뒤의 공백은 무시)
    - 변환 불가는 `NaN` 리턴
  - `parseInt`: 문자열을 정수로 해석해서 리턴
    - 문자열이 아니면 문자열로 변환한 뒤에 정수로 해석
    - 두번째 인수로 진법(2~36) 전달하면 첫번째 인수를 해당 진수로 해석하고 결과값을 10진수로 리턴 (ㅇ진수->10진수 변환, 10진수->ㅇ진수 변환은 `Number.prototype.toString()` 사용)
    - 두번째 인수 전달 안해도 첫번째 인수가 `0x`/`0X`면 16진수로 해석(2진수는 안됨, 8진수는 ES6전까지만 가능)
    - 해당 진법으로 해석 안되면 `NaN`
    - 해당 진법으로 해석할 수 있는데까지만 해석하고 그 이후는 무시해서 리턴
    - 공백이 포함된 문자열은 첫번째 문자열만 변환(맨 앞과 맨 뒤의 공백은 무시)
    - `encodeURI`/`decodeURI`: URI를 문자열로 전달받아 이스케이프 처리(아스키 문자 세트로 변환)
    - `encodeURIComponent`/`decodeURIComponent`: URI 구성 요소를 전달받아 이스케이프 처리
- 암묵적 전역: 선언하지 않은 변수에 할당하면 전역 객체헤 프로퍼티가 동적 생성됨
  - 변수는 아니라서 변수 호이스팅은 안 일어남
  - 프로퍼티라서 `delete`로 삭제 가능



